<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Python Script Interface &#8212; HybMesh 0.5.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Example 1" href="intro_example1.html" />
    <link rel="prev" title="Grid Prototypes" href="prototypes.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro_example1.html" title="Example 1"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="prototypes.html" title="Grid Prototypes"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">HybMesh 0.5.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="python-script-interface">
<span id="pyinterf"></span><h1>Python Script Interface<a class="headerlink" href="#python-script-interface" title="Permalink to this headline">¶</a></h1>
<div class="section" id="script-invocation">
<h2>Script Invocation<a class="headerlink" href="#script-invocation" title="Permalink to this headline">¶</a></h2>
<p>HybMesh script is a normal python file which
supports all capabilities of python language and can be invoked using both
HybMesh standalone application and <em>Python 2.7</em> interpreter.
The latter demands HybMesh be installed as a python module
(see <a class="reference internal" href="installation.html#installation"><span class="std std-ref">Installation</span></a>).</p>
<p>To invoke a script from python interpreter use a command (if <cite>python</cite> refers to <cite>python2.7</cite>)</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">&gt;</span> python yourscript.py
</pre></div>
</div>
<p>For standalone <a class="reference internal" href="usage.html#consoleapp"><span class="std std-ref">Console Application</span></a> in Windows type</p>
<div class="highlight-bat"><div class="highlight"><pre><span></span><span class="p">&gt;</span> c:\path\to\bin\hybmesh.exe -sx yourscript.py
</pre></div>
</div>
<p>In Linux the default application install path <cite>/usr/local/bin</cite>
should present in your system paths, so there is no need to type full path
to executable.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">&gt;</span> hybmesh -sx yourscript.py
</pre></div>
</div>
<p>HybMesh functionality is scattered across different modules of
<code class="xref py py-mod docutils literal"><span class="pre">hybmeshpack</span></code> package. However all imports essential for scripting
are gathered in <code class="docutils literal"><span class="pre">hybmeshpack.hmscripts.__init__</span></code>,
so the HybMesh script file should start with respective import line.
Below is a helloworld example which creates a <code class="docutils literal"><span class="pre">2x2</span></code> grid and reports its structure.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">hybmeshpack</span> <span class="kn">import</span> <span class="n">hmscript</span> <span class="k">as</span> <span class="n">hm</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">add_unf_rect_grid</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">print</span> <span class="n">hm</span><span class="o">.</span><span class="n">info_grid</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<span class="target" id="module-hybmeshpack.hmscript"></span></div>
<div class="section" id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h2>
<p>All hybmesh operable geometrical objects
are represented by their internal unique string
identifiers. To get the full list of all registered identifiers
use <code class="docutils literal"><span class="pre">'registered_*'</span></code> functions.
If an identifier leaves current scope
it doesn&#8217;t lead to disposing of respective object.
You should use <a class="reference internal" href="#hybmeshpack.hmscript.remove_geom" title="hybmeshpack.hmscript.remove_geom"><code class="xref py py-func docutils literal"><span class="pre">remove_geom()</span></code></a> function to explicitly
remove an object. Use <a class="reference internal" href="#hybmeshpack.hmscript.remove_all_but" title="hybmeshpack.hmscript.remove_all_but"><code class="xref py py-func docutils literal"><span class="pre">remove_all_but()</span></code></a> to
clean the garbage and leave only those objects
which are actually needed.</p>
<p>To get full information about object geometry
(vertices coordinates and index based connectivity tables) use
<code class="docutils literal"><span class="pre">'tab_*'</span></code> set of functions.
For performance reasons these functions return ctypes plain 1D arrays.
Use ordinary <code class="docutils literal"><span class="pre">[i]</span></code> notation to access entries of these arrays
or convert it to python list by <code class="docutils literal"><span class="pre">pylist</span> <span class="pre">=</span> <span class="pre">ctypes_array[:]</span></code> line.</p>
<p>Boundary (zone) types are defined by non-negative integers.
Default zone type (equals <code class="docutils literal"><span class="pre">0</span></code>) is used if it was not explicitly defined.
You could use <a class="reference internal" href="#hybmeshpack.hmscript.add_boundary_type" title="hybmeshpack.hmscript.add_boundary_type"><code class="xref py py-func docutils literal"><span class="pre">add_boundary_type()</span></code></a>
function to link this integer to a string which will be
used in object export procedures.</p>
</div>
<div class="section" id="exception-handling">
<h2>Exception Handling<a class="headerlink" href="#exception-handling" title="Permalink to this headline">¶</a></h2>
<p>All hybmesh function may throw two types of exceptions:</p>
<dl class="exception">
<dt id="hybmeshpack.hmscript.ExecError">
<em class="property">exception </em><code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">ExecError</code><span class="sig-paren">(</span><em>funname</em>, <em>msg</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.ExecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised if hmscript function fails</p>
</dd></dl>

<dl class="exception">
<dt id="hybmeshpack.hmscript.InvalidArgument">
<em class="property">exception </em><code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">InvalidArgument</code><span class="sig-paren">(</span><em>msg=''</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.InvalidArgument" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when user passes invalid argument to a hmscript function</p>
</dd></dl>

<p>Before execution of any hybmesh function a quick
input data check is performed. It examines
argument types, ranges and consistency.
If it fails then <a class="reference internal" href="#hybmeshpack.hmscript.InvalidArgument" title="hybmeshpack.hmscript.InvalidArgument"><code class="xref py py-func docutils literal"><span class="pre">InvalidArgument()</span></code></a> is raised.
If output verbosity level is not set to zero, then
detailed information regarding this error including
unity based index of invalid argument, its actual value and program expectations
will be flushed to console.</p>
<p>If program fails during function execution
then <a class="reference internal" href="#hybmeshpack.hmscript.ExecError" title="hybmeshpack.hmscript.ExecError"><code class="xref py py-func docutils literal"><span class="pre">ExecError()</span></code></a> will be raised.
Information about function arguments and traceback
will be printed to console.</p>
<p>Both exceptions could be safely caught and handled.</p>
</div>
<div class="section" id="list-of-functions">
<span id="pyfunclist"></span><h2>List of Functions<a class="headerlink" href="#list-of-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general-routines">
<h3>General routines<a class="headerlink" href="#general-routines" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.check_compatibility" title="hybmeshpack.hmscript.check_compatibility"><code class="xref py py-func docutils literal"><span class="pre">check_compatibility()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.registered_contours" title="hybmeshpack.hmscript.registered_contours"><code class="xref py py-func docutils literal"><span class="pre">registered_contours()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.registered_grids" title="hybmeshpack.hmscript.registered_grids"><code class="xref py py-func docutils literal"><span class="pre">registered_grids()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.registered_surfaces" title="hybmeshpack.hmscript.registered_surfaces"><code class="xref py py-func docutils literal"><span class="pre">registered_surfaces()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.registered_grids3d" title="hybmeshpack.hmscript.registered_grids3d"><code class="xref py py-func docutils literal"><span class="pre">registered_grids3d()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.registered_btypes" title="hybmeshpack.hmscript.registered_btypes"><code class="xref py py-func docutils literal"><span class="pre">registered_btypes()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.remove_all" title="hybmeshpack.hmscript.remove_all"><code class="xref py py-func docutils literal"><span class="pre">remove_all()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.remove_all_but" title="hybmeshpack.hmscript.remove_all_but"><code class="xref py py-func docutils literal"><span class="pre">remove_all_but()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.copy_geom" title="hybmeshpack.hmscript.copy_geom"><code class="xref py py-func docutils literal"><span class="pre">copy_geom()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.move_geom" title="hybmeshpack.hmscript.move_geom"><code class="xref py py-func docutils literal"><span class="pre">move_geom()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.rotate_geom" title="hybmeshpack.hmscript.rotate_geom"><code class="xref py py-func docutils literal"><span class="pre">rotate_geom()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.scale_geom" title="hybmeshpack.hmscript.scale_geom"><code class="xref py py-func docutils literal"><span class="pre">scale_geom()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.reflect_geom" title="hybmeshpack.hmscript.reflect_geom"><code class="xref py py-func docutils literal"><span class="pre">reflect_geom()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.remove_geom" title="hybmeshpack.hmscript.remove_geom"><code class="xref py py-func docutils literal"><span class="pre">remove_geom()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.add_boundary_type" title="hybmeshpack.hmscript.add_boundary_type"><code class="xref py py-func docutils literal"><span class="pre">add_boundary_type()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.set_boundary_type" title="hybmeshpack.hmscript.set_boundary_type"><code class="xref py py-func docutils literal"><span class="pre">set_boundary_type()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.partition_segment" title="hybmeshpack.hmscript.partition_segment"><code class="xref py py-func docutils literal"><span class="pre">partition_segment()</span></code></a></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="contour-operations">
<h3>Contour operations<a class="headerlink" href="#contour-operations" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.info_contour" title="hybmeshpack.hmscript.info_contour"><code class="xref py py-func docutils literal"><span class="pre">info_contour()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.tab_cont2" title="hybmeshpack.hmscript.tab_cont2"><code class="xref py py-func docutils literal"><span class="pre">tab_cont2()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.domain_area" title="hybmeshpack.hmscript.domain_area"><code class="xref py py-func docutils literal"><span class="pre">domain_area()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.get_point" title="hybmeshpack.hmscript.get_point"><code class="xref py py-func docutils literal"><span class="pre">get_point()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.pick_contour" title="hybmeshpack.hmscript.pick_contour"><code class="xref py py-func docutils literal"><span class="pre">pick_contour()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.create_contour" title="hybmeshpack.hmscript.create_contour"><code class="xref py py-func docutils literal"><span class="pre">create_contour()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.create_spline_contour" title="hybmeshpack.hmscript.create_spline_contour"><code class="xref py py-func docutils literal"><span class="pre">create_spline_contour()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.add_rect_contour" title="hybmeshpack.hmscript.add_rect_contour"><code class="xref py py-func docutils literal"><span class="pre">add_rect_contour()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.add_circ_contour" title="hybmeshpack.hmscript.add_circ_contour"><code class="xref py py-func docutils literal"><span class="pre">add_circ_contour()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.add_circ_contour2" title="hybmeshpack.hmscript.add_circ_contour2"><code class="xref py py-func docutils literal"><span class="pre">add_circ_contour2()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.add_circ_contour3" title="hybmeshpack.hmscript.add_circ_contour3"><code class="xref py py-func docutils literal"><span class="pre">add_circ_contour3()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.unite_contours" title="hybmeshpack.hmscript.unite_contours"><code class="xref py py-func docutils literal"><span class="pre">unite_contours()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.clip_domain" title="hybmeshpack.hmscript.clip_domain"><code class="xref py py-func docutils literal"><span class="pre">clip_domain()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.simplify_contour" title="hybmeshpack.hmscript.simplify_contour"><code class="xref py py-func docutils literal"><span class="pre">simplify_contour()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.grid_bnd_to_contour" title="hybmeshpack.hmscript.grid_bnd_to_contour"><code class="xref py py-func docutils literal"><span class="pre">grid_bnd_to_contour()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.partition_contour" title="hybmeshpack.hmscript.partition_contour"><code class="xref py py-func docutils literal"><span class="pre">partition_contour()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.matched_partition" title="hybmeshpack.hmscript.matched_partition"><code class="xref py py-func docutils literal"><span class="pre">matched_partition()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.decompose_contour" title="hybmeshpack.hmscript.decompose_contour"><code class="xref py py-func docutils literal"><span class="pre">decompose_contour()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.extract_subcontours" title="hybmeshpack.hmscript.extract_subcontours"><code class="xref py py-func docutils literal"><span class="pre">extract_subcontours()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.connect_subcontours" title="hybmeshpack.hmscript.connect_subcontours"><code class="xref py py-func docutils literal"><span class="pre">connect_subcontours()</span></code></a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="d-grid-operations">
<h3>2D grid operations<a class="headerlink" href="#d-grid-operations" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.info_grid" title="hybmeshpack.hmscript.info_grid"><code class="xref py py-func docutils literal"><span class="pre">info_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.tab_grid2" title="hybmeshpack.hmscript.tab_grid2"><code class="xref py py-func docutils literal"><span class="pre">tab_grid2()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.skewness" title="hybmeshpack.hmscript.skewness"><code class="xref py py-func docutils literal"><span class="pre">skewness()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.heal_grid" title="hybmeshpack.hmscript.heal_grid"><code class="xref py py-func docutils literal"><span class="pre">heal_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.add_unf_rect_grid" title="hybmeshpack.hmscript.add_unf_rect_grid"><code class="xref py py-func docutils literal"><span class="pre">add_unf_rect_grid()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.add_unf_circ_grid" title="hybmeshpack.hmscript.add_unf_circ_grid"><code class="xref py py-func docutils literal"><span class="pre">add_unf_circ_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.add_unf_ring_grid" title="hybmeshpack.hmscript.add_unf_ring_grid"><code class="xref py py-func docutils literal"><span class="pre">add_unf_ring_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.add_unf_hex_grid" title="hybmeshpack.hmscript.add_unf_hex_grid"><code class="xref py py-func docutils literal"><span class="pre">add_unf_hex_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.add_triangle_grid" title="hybmeshpack.hmscript.add_triangle_grid"><code class="xref py py-func docutils literal"><span class="pre">add_triangle_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.add_custom_rect_grid" title="hybmeshpack.hmscript.add_custom_rect_grid"><code class="xref py py-func docutils literal"><span class="pre">add_custom_rect_grid()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.add_circ_rect_grid" title="hybmeshpack.hmscript.add_circ_rect_grid"><code class="xref py py-func docutils literal"><span class="pre">add_circ_rect_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.stripe" title="hybmeshpack.hmscript.stripe"><code class="xref py py-func docutils literal"><span class="pre">stripe()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.triangulate_domain" title="hybmeshpack.hmscript.triangulate_domain"><code class="xref py py-func docutils literal"><span class="pre">triangulate_domain()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.pebi_fill" title="hybmeshpack.hmscript.pebi_fill"><code class="xref py py-func docutils literal"><span class="pre">pebi_fill()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.unite_grids" title="hybmeshpack.hmscript.unite_grids"><code class="xref py py-func docutils literal"><span class="pre">unite_grids()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.unite_grids1" title="hybmeshpack.hmscript.unite_grids1"><code class="xref py py-func docutils literal"><span class="pre">unite_grids1()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.snap_grid_to_contour" title="hybmeshpack.hmscript.snap_grid_to_contour"><code class="xref py py-func docutils literal"><span class="pre">snap_grid_to_contour()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.build_boundary_grid" title="hybmeshpack.hmscript.build_boundary_grid"><code class="xref py py-func docutils literal"><span class="pre">build_boundary_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.build_boundary_grid1" title="hybmeshpack.hmscript.build_boundary_grid1"><code class="xref py py-func docutils literal"><span class="pre">build_boundary_grid1()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.exclude_contours" title="hybmeshpack.hmscript.exclude_contours"><code class="xref py py-func docutils literal"><span class="pre">exclude_contours()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.map_grid" title="hybmeshpack.hmscript.map_grid"><code class="xref py py-func docutils literal"><span class="pre">map_grid()</span></code></a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="surface-operations">
<h3>Surface operations<a class="headerlink" href="#surface-operations" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.info_surface" title="hybmeshpack.hmscript.info_surface"><code class="xref py py-func docutils literal"><span class="pre">info_surface()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.tab_surf3" title="hybmeshpack.hmscript.tab_surf3"><code class="xref py py-func docutils literal"><span class="pre">tab_surf3()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.grid3_bnd_to_surface" title="hybmeshpack.hmscript.grid3_bnd_to_surface"><code class="xref py py-func docutils literal"><span class="pre">grid3_bnd_to_surface()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.domain_volume" title="hybmeshpack.hmscript.domain_volume"><code class="xref py py-func docutils literal"><span class="pre">domain_volume()</span></code></a></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id1">
<h3>3D grid operations<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.info_grid3d" title="hybmeshpack.hmscript.info_grid3d"><code class="xref py py-func docutils literal"><span class="pre">info_grid3d()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.tab_grid3" title="hybmeshpack.hmscript.tab_grid3"><code class="xref py py-func docutils literal"><span class="pre">tab_grid3()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.extrude_grid" title="hybmeshpack.hmscript.extrude_grid"><code class="xref py py-func docutils literal"><span class="pre">extrude_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.revolve_grid" title="hybmeshpack.hmscript.revolve_grid"><code class="xref py py-func docutils literal"><span class="pre">revolve_grid()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.tetrahedral_fill" title="hybmeshpack.hmscript.tetrahedral_fill"><code class="xref py py-func docutils literal"><span class="pre">tetrahedral_fill()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.merge_grids3" title="hybmeshpack.hmscript.merge_grids3"><code class="xref py py-func docutils literal"><span class="pre">merge_grids3()</span></code></a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="export">
<span id="pyinterf-export"></span><h3>Export<a class="headerlink" href="#export" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.export_grid_hmg" title="hybmeshpack.hmscript.export_grid_hmg"><code class="xref py py-func docutils literal"><span class="pre">export_grid_hmg()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export_grid_vtk" title="hybmeshpack.hmscript.export_grid_vtk"><code class="xref py py-func docutils literal"><span class="pre">export_grid_vtk()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export_grid_msh" title="hybmeshpack.hmscript.export_grid_msh"><code class="xref py py-func docutils literal"><span class="pre">export_grid_msh()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export_grid_gmsh" title="hybmeshpack.hmscript.export_grid_gmsh"><code class="xref py py-func docutils literal"><span class="pre">export_grid_gmsh()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export_grid_tecplot" title="hybmeshpack.hmscript.export_grid_tecplot"><code class="xref py py-func docutils literal"><span class="pre">export_grid_tecplot()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.export_contour_hmc" title="hybmeshpack.hmscript.export_contour_hmc"><code class="xref py py-func docutils literal"><span class="pre">export_contour_hmc()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export_contour_vtk" title="hybmeshpack.hmscript.export_contour_vtk"><code class="xref py py-func docutils literal"><span class="pre">export_contour_vtk()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export_contour_tecplot" title="hybmeshpack.hmscript.export_contour_tecplot"><code class="xref py py-func docutils literal"><span class="pre">export_contour_tecplot()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export3d_grid_hmg" title="hybmeshpack.hmscript.export3d_grid_hmg"><code class="xref py py-func docutils literal"><span class="pre">export3d_grid_hmg()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export3d_grid_vtk" title="hybmeshpack.hmscript.export3d_grid_vtk"><code class="xref py py-func docutils literal"><span class="pre">export3d_grid_vtk()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.export3d_grid_gmsh" title="hybmeshpack.hmscript.export3d_grid_gmsh"><code class="xref py py-func docutils literal"><span class="pre">export3d_grid_gmsh()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export3d_grid_msh" title="hybmeshpack.hmscript.export3d_grid_msh"><code class="xref py py-func docutils literal"><span class="pre">export3d_grid_msh()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export3d_grid_tecplot" title="hybmeshpack.hmscript.export3d_grid_tecplot"><code class="xref py py-func docutils literal"><span class="pre">export3d_grid_tecplot()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export3d_surface_hmc" title="hybmeshpack.hmscript.export3d_surface_hmc"><code class="xref py py-func docutils literal"><span class="pre">export3d_surface_hmc()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.export_all_hmd" title="hybmeshpack.hmscript.export_all_hmd"><code class="xref py py-func docutils literal"><span class="pre">export_all_hmd()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.save_project" title="hybmeshpack.hmscript.save_project"><code class="xref py py-func docutils literal"><span class="pre">save_project()</span></code></a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="import">
<span id="pyinterf-import"></span><h3>Import<a class="headerlink" href="#import" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hybmeshpack.hmscript.import_grid_hmg" title="hybmeshpack.hmscript.import_grid_hmg"><code class="xref py py-func docutils literal"><span class="pre">import_grid_hmg()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.import_grid_msh" title="hybmeshpack.hmscript.import_grid_msh"><code class="xref py py-func docutils literal"><span class="pre">import_grid_msh()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.import_grid_gmsh" title="hybmeshpack.hmscript.import_grid_gmsh"><code class="xref py py-func docutils literal"><span class="pre">import_grid_gmsh()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.import_contour_hmc" title="hybmeshpack.hmscript.import_contour_hmc"><code class="xref py py-func docutils literal"><span class="pre">import_contour_hmc()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.import3d_grid_hmg" title="hybmeshpack.hmscript.import3d_grid_hmg"><code class="xref py py-func docutils literal"><span class="pre">import3d_grid_hmg()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hybmeshpack.hmscript.import3d_surface_hmc" title="hybmeshpack.hmscript.import3d_surface_hmc"><code class="xref py py-func docutils literal"><span class="pre">import3d_surface_hmc()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.import_all_hmd" title="hybmeshpack.hmscript.import_all_hmd"><code class="xref py py-func docutils literal"><span class="pre">import_all_hmd()</span></code></a></td>
<td><a class="reference internal" href="#hybmeshpack.hmscript.load_project" title="hybmeshpack.hmscript.load_project"><code class="xref py py-func docutils literal"><span class="pre">load_project()</span></code></a></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="general-procedures">
<h2>General Procedures<a class="headerlink" href="#general-procedures" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="hybmeshpack.hmscript.check_compatibility">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">check_compatibility</code><span class="sig-paren">(</span><em>vers</em>, <em>policy=1</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.check_compatibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks version compatibility. Notifies if current version
of hymbesh is not fully compatible with input version.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vers</strong> (<em>str</em>) &#8211; version in <code class="docutils literal"><span class="pre">&quot;0.1.2&quot;</span></code> format</li>
<li><strong>policy</strong> (<em>int</em>) &#8211; <p>if versions are incompatible then:</p>
<ul>
<li>0 - do nothing (return False)</li>
<li>1 - report warning to cout</li>
<li>2 - raise ExecError</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">False if versions are incompatible, True otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.registered_contours">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">registered_contours</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.registered_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of all contour identifiers</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.registered_grids">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">registered_grids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.registered_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of all 2d grid identifiers</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.registered_surfaces">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">registered_surfaces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.registered_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of all surface identifiers</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.registered_grids3d">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">registered_grids3d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.registered_grids3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of all 3d grid identifiers</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.registered_btypes">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">registered_btypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.registered_btypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of all boundary types as list of (index, name) tuples</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.remove_all">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">remove_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.remove_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Completely removes all geometry objects and boundary types</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.remove_all_but">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">remove_all_but</code><span class="sig-paren">(</span><em>objs</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.remove_all_but" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all geometry objects except for listed ones</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>objs</strong> &#8211; identifier or list of identifiers of objects
which should NOT be removed</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.copy_geom">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">copy_geom</code><span class="sig-paren">(</span><em>objs</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.copy_geom" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates deep copies of geometry objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>objs</strong> &#8211; identifier or list of identifiers of objects to copy</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of identifiers of copied objects in oder prescribed by
input list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.move_geom">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">move_geom</code><span class="sig-paren">(</span><em>objs</em>, <em>dx</em>, <em>dy</em>, <em>dz=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.move_geom" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves a list of objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>objs</strong> &#8211; identifier or list of identifiers of moving objects</li>
<li><strong>dx</strong> (<em>float</em>) &#8211; </li>
<li><strong>dy</strong> (<em>float</em>) &#8211; </li>
<li><strong>dz</strong> (<em>float</em>) &#8211; shifts in x, y and z direction. Z moves take place only
for 3d objects</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.rotate_geom">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">rotate_geom</code><span class="sig-paren">(</span><em>objs, angle, pc=[0.0, 0.0]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.rotate_geom" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates group of 2d objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>objs</strong> &#8211; identifier or list of identifiers of rotating 2d objects</li>
<li><strong>angle</strong> (<em>float</em>) &#8211; degree of rotation. Positive angle corresponds to
counterclockwise rotation</li>
<li><strong>pc</strong> (<em>list-of-float</em>) &#8211; center of rotation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.scale_geom">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">scale_geom</code><span class="sig-paren">(</span><em>objs, xpc=100.0, ypc=100.0, zpc=100.0, refp=[0.0, 0.0, 0.0]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.scale_geom" title="Permalink to this definition">¶</a></dt>
<dd><p>Scales objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>objs</strong> &#8211; identifier or list of identifiers of scaling objects</li>
<li><strong>xpc</strong> (<em>float</em>) &#8211; </li>
<li><strong>ypc</strong> (<em>float</em>) &#8211; </li>
<li><strong>zpc</strong> (<em>float</em>) &#8211; percentages of scaling in x, y and z directions</li>
<li><strong>refp</strong> (<em>list-of-float</em>) &#8211; reference point as <code class="docutils literal"><span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code> which stays
fixed after transformation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p>if <strong>objs</strong> contains only 2d objects <strong>zpc</strong> is ignored and could be
ommitted, <strong>refp</strong> could by given as <code class="docutils literal"><span class="pre">[x,</span> <span class="pre">y]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.reflect_geom">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">reflect_geom</code><span class="sig-paren">(</span><em>objs</em>, <em>pnt1</em>, <em>pnt2</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.reflect_geom" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a reflection of 2d geometry objects over a  given line</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>objs</strong> &#8211; identifier or list of identifiers of 2d objects to reflect</li>
<li><strong>pnt1</strong> (<em>list-of-float</em>) &#8211; </li>
<li><strong>pnt2</strong> (<em>list-of-float</em>) &#8211; points in [x, y] format which define a line
to reflect over</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.remove_geom">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">remove_geom</code><span class="sig-paren">(</span><em>objs</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.remove_geom" title="Permalink to this definition">¶</a></dt>
<dd><p>Completely removes object or list of objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>objs</strong> &#8211; identifier or list of identifiers of removing objects</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_boundary_type">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_boundary_type</code><span class="sig-paren">(</span><em>index</em>, <em>name='boundary1'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_boundary_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Register boundary type name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>index</strong> (<em>int</em>) &#8211; index of boundary (&gt;0)</li>
<li><strong>name</strong> (<em>str</em>) &#8211; user defined name of the boundary</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">integer boundary identifier</p>
</td>
</tr>
</tbody>
</table>
<p>If boundary with <code class="docutils literal"><span class="pre">index</span></code> already exists it will be overwritten.
Name of the boundary should be unique, if name already exists it will
be changed automatically.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.set_boundary_type">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">set_boundary_type</code><span class="sig-paren">(</span><em>obj</em>, <em>btps=None</em>, <em>bfun=None</em>, <em>bdict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.set_boundary_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark geometrical object with boundary types.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>obj</strong> &#8211; geometric object identifier</li>
<li><strong>btps</strong> &#8211; single identifier for the whole object or list
of identifiers for each boundary segment.</li>
<li><strong>bfun</strong> &#8211; function which returns boundary type taking segment
coordinates and old boundary type as arguments.</li>
<li><strong>bdict</strong> &#8211; {btype: [list-of-segment indicies]} dictionary
which maps boundary type with object segments indicies</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Only one of <strong>btps</strong>, <strong>bfun</strong>, <strong>bdict</strong> arguments should be defined.</p>
<p><strong>bfun</strong> signature is:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">(x0,</span> <span class="pre">y0,</span> <span class="pre">x1,</span> <span class="pre">y1,</span> <span class="pre">bt)</span> <span class="pre">-&gt;</span> <span class="pre">btype</span></code> for 2D objects, where
<em>x0, y0, x1, y1</em> are edge end point coordinates,
bt - old boundary type</li>
<li><code class="docutils literal"><span class="pre">(xc,</span> <span class="pre">yc,</span> <span class="pre">zc,</span> <span class="pre">bt)</span> <span class="pre">-&gt;</span> <span class="pre">btype</span></code> for 3D objects, where
<em>xc, yc, zc</em> - approximate face center coordinates,
bt - old boundary type</li>
</ul>
</div></blockquote>
<p>If <strong>obj</strong> is a grid then only boundary segments will be passed
to <strong>bfun</strong> function and <strong>btps</strong> list entries will
be associated with boundary segments only.
However <strong>bdict</strong> entries should contain global edge or face indicies.</p>
<p>Example:</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># mark b1, b2 as globals so binfo function can find them</span>
<span class="k">global</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span>
<span class="c1"># register boundary types</span>
<span class="n">b1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_boundary_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;vertical&quot;</span><span class="p">)</span>
<span class="n">b2</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_boundary_type</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;horizontal&quot;</span><span class="p">)</span>
<span class="c1"># create rectangular contours</span>
<span class="n">cont1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_rect_contour</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="c1"># mark contour using `btps`</span>
<span class="n">hmscript</span><span class="o">.</span><span class="n">set_boundary_type</span><span class="p">(</span><span class="n">cont1</span><span class="p">,</span> <span class="n">btps</span><span class="o">=</span><span class="p">[</span><span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="p">])</span>
<span class="c1"># same effect using `bfun`</span>
<span class="n">cont2</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_rect_contour</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">binfo</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">bold</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">b1</span> <span class="k">if</span> <span class="n">x0</span> <span class="o">==</span> <span class="n">x1</span> <span class="k">else</span> <span class="n">b2</span>
<span class="n">hmscript</span><span class="o">.</span><span class="n">set_boundary_type</span><span class="p">(</span><span class="n">cont2</span><span class="p">,</span> <span class="n">bfun</span><span class="o">=</span><span class="n">binfo</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.partition_segment">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">partition_segment</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>hstart</em>, <em>hend</em>, <em>hinternal=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.partition_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a partition of numeric segment by given
recommended step sizes at different locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<em>float</em>) &#8211; </li>
<li><strong>end</strong> (<em>float</em>) &#8211; start and end points of numeric segment.</li>
<li><strong>hstart</strong> (<em>float</em>) &#8211; </li>
<li><strong>hend</strong> (<em>float</em>) &#8211; recommended step at the beginning and at the
end of numeric segments</li>
<li><strong>hinternal</strong> (<em>list-of-floats</em>) &#8211; possible internal recommended steps
given as [segment value0, step0, segment value1, step1, ...]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">increasing float list representing
partitioned segment [start, ..(internal steps).., end]</p>
</td>
</tr>
</tbody>
</table>
<p>This is a helper function which runs iterative procedure
to adopt partition of the segment to user defined step size
recommendations. It could be used for example to
explicitly define partition in <a class="reference internal" href="#hybmeshpack.hmscript.add_unf_rect_grid" title="hybmeshpack.hmscript.add_unf_rect_grid"><code class="xref py py-func docutils literal"><span class="pre">add_unf_rect_grid()</span></code></a>,
<a class="reference internal" href="#hybmeshpack.hmscript.add_unf_circ_grid" title="hybmeshpack.hmscript.add_unf_circ_grid"><code class="xref py py-func docutils literal"><span class="pre">add_unf_circ_grid()</span></code></a> with given <cite>custom_*</cite> options or
vertical partition of boundary grid in <a class="reference internal" href="#hybmeshpack.hmscript.build_boundary_grid" title="hybmeshpack.hmscript.build_boundary_grid"><code class="xref py py-func docutils literal"><span class="pre">build_boundary_grid()</span></code></a>.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><p class="first">Shows division of [1, 2] segment from approximately 0.1
step size at the beginning to approximately 0.5 step size at
the end</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span> <span class="n">hm</span><span class="o">.</span><span class="n">partition_segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.1238348</span><span class="p">,</span> <span class="mf">1.309012</span><span class="p">,</span> <span class="mf">1.585923</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>
</pre></div>
</div>
<p>Shows division of [1, 2] segment with approximate 0.1
step sizes at its end points and 0.4 step size at the center.</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span> <span class="n">hm</span><span class="o">.</span><span class="n">partition_segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.1082238</span><span class="p">,</span> <span class="mf">1.3278488</span><span class="p">,</span> <span class="mf">1.672151</span><span class="p">,</span> <span class="mf">1.891776</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="id2">
<h2>Contour Operations<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="hybmeshpack.hmscript.info_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">info_contour</code><span class="sig-paren">(</span><em>cid</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.info_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Get contour structure information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cid</strong> &#8211; contour or grid identifier</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dictionary representing contour length, total number of nodes, edges,
number of edges in each subcontour and number of edges
of each boundary type:<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;Nnodes&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;Nedges&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;subcont&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">list</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="nb">int</span><span class="p">],</span>    <span class="c1"># edges number in each subcontour</span>
 <span class="s1">&#39;btypes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">btype</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span> <span class="nb">int</span><span class="p">}</span>  <span class="c1"># boundary type: number of edges</span>
 <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.tab_cont2">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">tab_cont2</code><span class="sig-paren">(</span><em>obj</em>, <em>what</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.tab_cont2" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns plain table for the given contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>obj</strong> (<em>str</em>) &#8211; contour identifier</li>
<li><strong>what</strong> (<em>str</em>) &#8211; table name</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">plain ctypes array representing requested table.</p>
</td>
</tr>
</tbody>
</table>
<p>Possible <strong>what</strong> values are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'vert'</span></code> - vertex coordinates table,</li>
<li><code class="docutils literal"><span class="pre">'edge_vert'</span></code> - edge-vertex connectivity: indices of first and
last vertices for each edge,</li>
<li><code class="docutils literal"><span class="pre">'bt'</span></code> - boundary features of each edge.</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.domain_area">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">domain_area</code><span class="sig-paren">(</span><em>cid</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.domain_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates area of the domain bounded by the contour</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cid</strong> &#8211; grid or contour identifier</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">positive float or zero for open contours</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.get_point">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">get_point</code><span class="sig-paren">(</span><em>obj</em>, <em>ind=None</em>, <em>vclosest=None</em>, <em>eclosest=None</em>, <em>cclosest=None</em>, <em>only_contour=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.get_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns object point</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>obj</strong> &#8211; grid or contour identifier</li>
<li><strong>ind</strong> (<em>int</em>) &#8211; index of point</li>
<li><strong>vclosest</strong> &#8211; </li>
<li><strong>eclosest</strong> &#8211; </li>
<li><strong>cclosest</strong> &#8211; point as [x, y] list</li>
<li><strong>only_contour</strong> (<em>bool</em>) &#8211; If that is true then if <strong>objs</strong> is a grid
then respective grid contour will be used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">point as [x, y] list</p>
</td>
</tr>
</tbody>
</table>
<p>Only one of <strong>ind</strong>, <strong>vclosest</strong>, <strong>eclosest</strong>, <strong>cclosest</strong>
arguments should be defined.</p>
<p>If <strong>ind</strong> is defined then returns point at given index.</p>
<p>If <strong>vvlosest</strong> point is defined then returns object vertex closest to
this point.</p>
<p>If <strong>eclosest</strong> point is defined then returns point owned by an
object edge closest to input point.</p>
<p>If <strong>cclosest</strong> point is defined then returns non straight line
object contour vertex closest to input point.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.pick_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">pick_contour</code><span class="sig-paren">(</span><em>pnt</em>, <em>contlist=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.pick_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns contour closest to given point</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pnt</strong> &#8211; point as [x, y] list</li>
<li><strong>contlist</strong> &#8211; list of contour identifier to choose from</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">closest contour identifier</p>
</td>
</tr>
</tbody>
</table>
<p>If <strong>contlist</strong> is empty then looks over all registered contours.
This procedure does not take 2d grid contours into account.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.create_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">create_contour</code><span class="sig-paren">(</span><em>pnts</em>, <em>bnds=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.create_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Create singly connected contour from sequence of points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pnts</strong> (<em>list-of-list-of-floats</em>) &#8211; sequence of points.
If coordinates of first and last points are equal
then contour is considered closed.</li>
<li><strong>bnds</strong> (<em>single-or-list-of-boundary-identifiers</em>) &#8211; boundary type for
each contour segment or single identifier for the whole contour.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">contour identifier</p>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Example:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hmscript</span><span class="o">.</span><span class="n">create_contour</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="go">                           [b1, b2, b3])</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.create_spline_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">create_spline_contour</code><span class="sig-paren">(</span><em>pnts</em>, <em>bnds=0</em>, <em>nedges=100</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.create_spline_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates singly connected contour as a parametric cubic spline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pnts</strong> (<em>list-of-list-of-floats</em>) &#8211; sequence of points.
If coordinates of first and last points are equal
then resulting contour will be closed.</li>
<li><strong>bnds</strong> (<em>single-or-list-of-boundary-identifiers</em>) &#8211; boundary type for
each contour segment bounded by <strong>pnts</strong>
or single identifier for the whole contour.</li>
<li><strong>nedges</strong> (<em>int</em>) &#8211; number of line segments of resulting contour.
Should be equal or greater than the number of sections defined by
<strong>pnts</strong>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">contour identifier</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_rect_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_rect_contour</code><span class="sig-paren">(</span><em>p0</em>, <em>p1</em>, <em>bnd=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_rect_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds four point closed rectangular contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> (<em>list-of-floats</em>) &#8211; </li>
<li><strong>p1</strong> (<em>list-of-floats</em>) &#8211; bottom left and top right coordinates of
the contour</li>
<li><strong>bnd</strong> &#8211; single or list of 4 boundary
identifiers (bottom, right, top, left) for contour segments.
With the default value no boundary types will be set.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Contour identifier</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_circ_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_circ_contour</code><span class="sig-paren">(</span><em>p0</em>, <em>rad</em>, <em>n_arc</em>, <em>bnd=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_circ_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds circle contour from given center and radius.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> (<em>list-of-floats</em>) &#8211; circle center in [x, y] format</li>
<li><strong>rad</strong> (<em>float</em>) &#8211; circle radius</li>
<li><strong>n_arc</strong> (<em>int</em>) &#8211; partition of circle arc</li>
<li><strong>bnd</strong> &#8211; boundary identifier for contour.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Contour identifier</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_circ_contour2">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_circ_contour2</code><span class="sig-paren">(</span><em>p0</em>, <em>p1</em>, <em>p2</em>, <em>n_arc</em>, <em>bnd=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_circ_contour2" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds circle contour from given arc points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> (<em>list-of-floats</em>) &#8211; </li>
<li><strong>p1</strong> (<em>list-of-floats</em>) &#8211; </li>
<li><strong>p2</strong> (<em>list-of-floats</em>) &#8211; circle arc points as [x, y] format</li>
<li><strong>n_arc</strong> (<em>int</em>) &#8211; partition of circle arc</li>
<li><strong>bnd</strong> &#8211; boundary identifier for contour.
With the default value no boundary types will be set.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Contour identifier</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_circ_contour3">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_circ_contour3</code><span class="sig-paren">(</span><em>p0</em>, <em>p1</em>, <em>curv</em>, <em>n_arc</em>, <em>bnd=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_circ_contour3" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds circle contour from given arc points and curvature.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> (<em>list-of-floats</em>) &#8211; </li>
<li><strong>p1</strong> (<em>list-of-floats</em>) &#8211; circle arc points in [x, y] format</li>
<li><strong>curv</strong> (<em>float</em>) &#8211; circle curvature. Equals <code class="docutils literal"><span class="pre">1.0/radius</span></code>.</li>
<li><strong>n_arc</strong> (<em>int</em>) &#8211; partition of circle arc</li>
<li><strong>bnd</strong> &#8211; boundary identifier for contour.
With the default value no boundary types will be set.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Contour identifier</p>
</td>
</tr>
</tbody>
</table>
<p>In the resulting circle <code class="docutils literal"><span class="pre">p0</span></code>-<code class="docutils literal"><span class="pre">p1</span></code> arc
with counterclockwise direction will be shorter then
<code class="docutils literal"><span class="pre">p1</span></code>-<code class="docutils literal"><span class="pre">p0</span></code> arc.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.unite_contours">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">unite_contours</code><span class="sig-paren">(</span><em>conts</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.unite_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>Unites contours to single multiply connected contour</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>conts</strong> &#8211; list of contours identifiers to unite</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">contour identifier</td>
</tr>
</tbody>
</table>
<p>Equal nodes and segments of input contours will be merged.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.clip_domain">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">clip_domain</code><span class="sig-paren">(</span><em>dom1</em>, <em>dom2</em>, <em>operation</em>, <em>simplify=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.clip_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes domain clipping procedure</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dom1</strong> &#8211; </li>
<li><strong>dom2</strong> &#8211; contour identifiers</li>
<li><strong>operatrion</strong> (<em>str</em>) &#8211; <p>operation code</p>
<ul>
<li><code class="docutils literal"><span class="pre">&quot;union&quot;</span></code></li>
<li><code class="docutils literal"><span class="pre">&quot;difference&quot;</span></code></li>
<li><code class="docutils literal"><span class="pre">&quot;intersection&quot;</span></code></li>
<li><code class="docutils literal"><span class="pre">&quot;xor&quot;</span></code></li>
</ul>
</li>
<li><strong>simplify</strong> (<em>bool</em>) &#8211; whether to keep all source points (False) or
return simplified contour</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">created contour identifier or None if resulting domain is empty</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.simplify_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">simplify_contour</code><span class="sig-paren">(</span><em>cont</em>, <em>simplify=True</em>, <em>angle=0.0</em>, <em>separate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.simplify_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Separates and simplify user contour</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cont</strong> &#8211; source contour or grid identifier</li>
<li><strong>simplify</strong> (<em>bool</em>) &#8211; do simplification, i.e. make all
segments non-collinear
Collinear segments will not be splitted if they have different
boundary types.</li>
<li><strong>angle</strong> (<em>degree</em>) &#8211; maximum allowed angle between simplified segments
(deg, &gt;=0).</li>
<li><strong>separate</strong> (<em>bool</em>) &#8211; assemble list of singly connected contours from
multiply connected source contour</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of created contours ids</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.grid_bnd_to_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">grid_bnd_to_contour</code><span class="sig-paren">(</span><em>gid</em>, <em>simplify=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.grid_bnd_to_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts grid boundary to user contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; grid identifier</li>
<li><strong>simplify</strong> (<em>bool</em>) &#8211; if true deletes all non-significant points. Otherwise
resulting contour will contain all boundary grid edges.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">contour identifier</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.partition_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">partition_contour</code><span class="sig-paren">(</span><em>cont</em>, <em>algo</em>, <em>step=1.0</em>, <em>angle0=30.0</em>, <em>keep_bnd=False</em>, <em>nedges=None</em>, <em>crosses=[]</em>, <em>keep_pts=[]</em>, <em>start=None</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.partition_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes connected contour partition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cont</strong> &#8211; Contour or grid identifier</li>
<li><strong>algo</strong> (<em>str</em>) &#8211; <p>Partition algorithm:</p>
<ul>
<li><code class="docutils literal"><span class="pre">'const'</span></code>: partition with defined constant step</li>
<li><code class="docutils literal"><span class="pre">'ref_points'</span></code>: partition with step function given by a
set of values refered to basic points</li>
<li><code class="docutils literal"><span class="pre">'ref_weights'</span></code>: partition with step function given by a
set of values refered to local contour [0, 1] coordinate</li>
<li><code class="docutils literal"><span class="pre">'ref_lengths'</span></code>: partition with step function given by a
set of values refered to local contour length coordinate</li>
</ul>
</li>
<li><strong>step</strong> &#8211; <p>For <code class="docutils literal"><span class="pre">algo='const'</span></code> a float number defining
partition step;</p>
<p>For <code class="docutils literal"><span class="pre">algo='ref_points'</span></code> - list of step values and point coordinates
given as
<code class="docutils literal"><span class="pre">[</span> <span class="pre">step_0,</span> <span class="pre">[x_0,</span> <span class="pre">y_0],</span> <span class="pre">step_1,</span> <span class="pre">[x_1,</span> <span class="pre">y_1],</span> <span class="pre">....]</span></code>.</p>
<p>For <code class="docutils literal"><span class="pre">algo='ref_weights'</span></code> - list of step values and point normalized
1d coordinates given as
<code class="docutils literal"><span class="pre">[</span> <span class="pre">step_0,</span> <span class="pre">w_0,</span> <span class="pre">step_1,</span> <span class="pre">w_1,</span> <span class="pre">....]</span></code>.</p>
<p>For <code class="docutils literal"><span class="pre">algo='ref_lengths'</span></code> - list of step values and point 1d
coordinates given as
<code class="docutils literal"><span class="pre">[</span> <span class="pre">step_0,</span> <span class="pre">s_0,</span> <span class="pre">step_1,</span> <span class="pre">s_1,</span> <span class="pre">....]</span></code>. Negative <code class="docutils literal"><span class="pre">s_i</span></code> shows
length coordinate started from end point in reversed direction.</p>
</li>
<li><strong>angle0</strong> (<em>float</em>) &#8211; existing contour vertices which provide
turns outside of <code class="docutils literal"><span class="pre">[180</span> <span class="pre">-</span> <span class="pre">angle0,</span> <span class="pre">180</span> <span class="pre">+</span> <span class="pre">angle0]</span></code> degrees range
will be preserved regardless of other options</li>
<li><strong>keep_bnd</strong> (<em>bool</em>) &#8211; if that is True than vertices which have different
boundary features on their right and left sides will be preserved</li>
<li><strong>nedges</strong> (<em>int</em>) &#8211; if this parameter is not None then it provides
exact number of edges in the resulting contour. To satisfy this
condition <strong>step</strong> value will be multiplied by an appropriate factor.
If it can not be satisfied (due to other restrictions)
then an exception will be raised.</li>
<li><strong>crosses</strong> &#8211; represents set of contour which cross points with
target contour will be present in resulting contour.</li>
<li><strong>keep_pts</strong> &#8211; list of points as <code class="docutils literal"><span class="pre">[[x1,</span> <span class="pre">y1],</span> <span class="pre">[x2,</span> <span class="pre">y2],</span> <span class="pre">...]</span></code> list
which should present in output partition.</li>
<li><strong>start</strong> &#8211; </li>
<li><strong>end</strong> &#8211; start and end points which define processing segment</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">new contour identifier</p>
</td>
</tr>
</tbody>
</table>
<p>Points set defined by user for <code class="docutils literal"><span class="pre">algo='ref_points'</span></code> algorithm
will not present in resulting contour (as well as points defined
implicitly by other <code class="docutils literal"><span class="pre">'ref_'</span></code> algorithms). It just shows locations
where step size of given length should be applied. If any point
of this set is not located on the input contour then it will be
projected to it.</p>
<p>For constant stepping any contour including multiply connected ones
could be passed. For <code class="docutils literal"><span class="pre">ref_</span></code> stepping only singly connected
contours (open or closed) are allowed.</p>
<p>If <strong>start</strong> and <strong>end</strong> points are defined then only segment between
these points will be parted. Note that all closed contours are treated
in counterclockwise direction. Given start/end points will be
projected to closest contour vertices.</p>
<p><code class="docutils literal"><span class="pre">ref_weights</span></code>, <code class="docutils literal"><span class="pre">ref_lengths</span></code> partition methods
require definition of <strong>start</strong> point
(To process whole contour <code class="docutils literal"><span class="pre">end</span></code> point could be omitted).</p>
<p>Example:</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># unit segment</span>
<span class="n">linear_segment</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">create_contour</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="c1"># divide into segments of length 0.03.</span>
<span class="c1"># part1 has 33 equal segments</span>
<span class="n">part1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">partition_contour</span><span class="p">(</span><span class="n">linear_segment</span><span class="p">,</span> <span class="s2">&quot;const&quot;</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.03</span><span class="p">)</span>

<span class="c1"># partition with refinement towards the center of input line</span>
<span class="c1"># segments near end points have length 0.1, at the center - 0.01,</span>
<span class="c1"># and between them linear size transition is applied</span>
<span class="n">part2</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">partition_contour</span><span class="p">(</span>
    <span class="n">linear_segment</span><span class="p">,</span> <span class="s2">&quot;ref_points&quot;</span><span class="p">,</span>
    <span class="n">step</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.01</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.1</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
</div></blockquote>
<p>See also: <a class="reference internal" href="functionality.html#simplecontmeshing"><span class="std std-ref">Simple contour meshing</span></a></p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.matched_partition">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">matched_partition</code><span class="sig-paren">(</span><em>cont</em>, <em>step</em>, <em>influence</em>, <em>ref_conts=[]</em>, <em>ref_pts=[]</em>, <em>angle0=30.0</em>, <em>power=3.0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.matched_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a contour partition with respect to other
contours partitions and given reference points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cont</strong> &#8211; target contour.</li>
<li><strong>step</strong> (<em>float</em>) &#8211; default contour step size.</li>
<li><strong>influence</strong> (<em>float</em>) &#8211; influence radius of size conditions.</li>
<li><strong>ref_conts</strong> &#8211; list of contours which segmentation will
be treated as target segmentation conditions.</li>
<li><strong>ref_pts</strong> &#8211; reference points given as
<code class="docutils literal"><span class="pre">[step0,</span> <span class="pre">[x0,</span> <span class="pre">y0],</span> <span class="pre">step1,</span> <span class="pre">[x1,</span> <span class="pre">y1],</span> <span class="pre">...]</span></code> list.</li>
<li><strong>angle0</strong> (<em>float</em>) &#8211; existing contour vertices which provide
turns outside of <code class="docutils literal"><span class="pre">[180</span> <span class="pre">-</span> <span class="pre">angle0,</span> <span class="pre">180</span> <span class="pre">+</span> <span class="pre">angle0]</span></code> degrees range
will be preserved regardless of other options</li>
<li><strong>power</strong> (<em>positive-float</em>) &#8211; shows power of weight
calculation function. As this parameter increases
size transitions along contour become less smooth and more
sensible to size conditions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>See <a class="reference internal" href="functionality.html#matchedcontmeshing"><span class="std std-ref">Matched contour meshing</span></a> for details.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.decompose_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">decompose_contour</code><span class="sig-paren">(</span><em>cont</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.decompose_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns set of simple singly connected contours built from
input contour</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cont</strong> &#8211; contour identifier</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of new contour identifiers</td>
</tr>
</tbody>
</table>
<p>All resulting contour vertices will have no more than two adjacent edges.
If input contour has vertices with more than two connections
(or self intersections) it will be splitted at these points.</p>
<p>Tries to assemble as many closed contours as possible.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.extract_subcontours">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">extract_subcontours</code><span class="sig-paren">(</span><em>source</em>, <em>plist</em>, <em>project_to='vertex'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.extract_subcontours" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts singly connected subcontours from given contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source</strong> &#8211; source contour identifier</li>
<li><strong>plist</strong> (<em>list-of-list-of-float</em>) &#8211; consecutive list of
subcontours end points</li>
<li><strong>project_to</strong> (<em>str</em>) &#8211; <p>defines projection rule for <strong>plist</strong> entries</p>
<ul>
<li><code class="docutils literal"><span class="pre">&quot;line&quot;</span></code> projects to closest point on the source contour</li>
<li><code class="docutils literal"><span class="pre">&quot;vertex&quot;</span></code> projects to closest contour vertex</li>
<li><code class="docutils literal"><span class="pre">&quot;corner&quot;</span></code> projects to closest contour corner vertex</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of new contours identifiers</p>
</td>
</tr>
</tbody>
</table>
<p>Length of <strong>plist</strong> should be equal or greater than two.
First and last points in <strong>plist</strong> define first and last points
of <strong>source</strong> segment to extract.
All internal points define internal division
of this segment. Hence number of resulting subcontours will equal
number of points in <strong>plist</strong> minus one.</p>
<p>For closed <strong>source</strong> contour first and last <strong>plist</strong> points
could coincide. In that case the sum of resulting subcontours
will be equal to <strong>source</strong>.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.connect_subcontours">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">connect_subcontours</code><span class="sig-paren">(</span><em>sources</em>, <em>fix=[]</em>, <em>close='no'</em>, <em>shiftnext=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.connect_subcontours" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects sequence of open contours into a single contour
even if neighboring contours have no equal end points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sources</strong> &#8211; list of open contour identifiers</li>
<li><strong>fix</strong> (<em>list-of-int</em>) &#8211; indicies of <strong>sources</strong> contours
which could not be shifted or stretched.</li>
<li><strong>close</strong> (<em>str</em>) &#8211; last connection algorithm:
<code class="docutils literal"><span class="pre">no</span></code>, <code class="docutils literal"><span class="pre">yes</span></code> or <code class="docutils literal"><span class="pre">force</span></code></li>
<li><strong>shiftnext</strong> (<em>bool</em>) &#8211; if True then each next contour will be
shifted to the end point of previous one, otherwise
both contours will be stretched to match average end point.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>To connect given contours this procedure implements stretching
and shifting of those ones not listed in <strong>fix</strong> list.
If two adjacent source contours are marked as fixed but have no
common end points an exception will be raised.</p>
<p>If <strong>close</strong> is <code class="docutils literal"><span class="pre">yes</span></code> then last contour of <strong>sources</strong> will
be connected with the first one with algorithm depending on
<strong>fix</strong> and <strong>shiftnext</strong> options.</p>
<p>If <strong>close</strong> is <code class="docutils literal"><span class="pre">no</span></code>
then ending contours will be left as they are. In that case resulting
contour will be open until first and last points are exactly equal.</p>
<p><strong>close</strong> = <code class="docutils literal"><span class="pre">force</span></code> algorithm works like <strong>close</strong> = <code class="docutils literal"><span class="pre">no</span></code> but
creates a section which explicitly connects first and last contours
by a straight line.</p>
</dd></dl>

</div>
<div class="section" id="id3">
<h2>2D Grid Operations<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="hybmeshpack.hmscript.info_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">info_grid</code><span class="sig-paren">(</span><em>gid</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.info_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Get grid structure information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gid</strong> &#8211; grid identifier</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dictionary which represents
total number of nodes/cells/edges
and number of cells of each type:<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;Nnodes&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;Ncells&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;Nedges&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;cell_types&#39;</span><span class="p">:</span> <span class="p">{</span><span class="nb">int</span><span class="p">:</span> <span class="nb">int</span><span class="p">}</span>  <span class="c1"># cell dimension: number of such cells</span>
 <span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.tab_grid2">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">tab_grid2</code><span class="sig-paren">(</span><em>obj</em>, <em>what</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.tab_grid2" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns plain table for the given grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>obj</strong> (<em>str</em>) &#8211; grid identifier</li>
<li><strong>what</strong> (<em>str</em>) &#8211; table name</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">plain ctypes array representing requested table.</p>
</td>
</tr>
</tbody>
</table>
<p>Possible <strong>what</strong> values are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'vert'</span></code> - vertex coordinates table,</li>
<li><code class="docutils literal"><span class="pre">'edge_vert'</span></code> - edge-vertex connectivity: indices of first and
last vertices for each edge,</li>
<li><code class="docutils literal"><span class="pre">'edge_cell'</span></code> - edge-cell connectivity: indices of left and right
cell for each edge. If this is a boundary edge <code class="docutils literal"><span class="pre">-1</span></code> is used to mark
boundary edge side,</li>
<li><code class="docutils literal"><span class="pre">'cell_dim'</span></code> - number of vertices in each cell,</li>
<li><code class="docutils literal"><span class="pre">'cell_edge'</span></code> - cell-edge connectivity: counterclockwise ordered 
edge indices for each cell.</li>
<li><code class="docutils literal"><span class="pre">'cell_vert'</span></code> - cell-vertex connectivity: counterclockwise ordered 
vertex indices for each cell.</li>
<li><code class="docutils literal"><span class="pre">'bnd'</span></code> - list of boundary edges indices,</li>
<li><code class="docutils literal"><span class="pre">'bt'</span></code> - boundary types for all edges including internal ones,</li>
<li><code class="docutils literal"><span class="pre">'bnd_bt'</span></code> - (boundary edge, boundary feature) pairs</li>
</ul>
<p>In case of grids with variable cell dimensions
<code class="docutils literal"><span class="pre">'cell_edge'</span></code> and <code class="docutils literal"><span class="pre">'cell_vert'</span></code> tables require
additional <code class="docutils literal"><span class="pre">'cell_dim'</span></code> table to subdive
returned plain array by certain cells.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.skewness">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">skewness</code><span class="sig-paren">(</span><em>gid</em>, <em>threshold=0.7</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.skewness" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports equiangular skewness coefficient (in [0, 1]) of grid cells</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; grid identifier</li>
<li><strong>threshold</strong> (<em>float</em>) &#8211; cells with skewness greater than this
value are considered bad and will be reported.
Set it to -1 to get skewness for each cell.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>dictionary with keys:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;ok&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>                  <span class="c1"># True if no bad_cells were found</span>
 <span class="s1">&#39;max_skew&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>           <span class="c1"># maximum skew value in grid</span>
 <span class="s1">&#39;max_skew_cell&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>        <span class="c1"># index of cell with maximum skew</span>
 <span class="s1">&#39;bad_cells&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">list</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="nb">int</span><span class="p">],</span>  <span class="c1"># list of bad cell indicies</span>
 <span class="s1">&#39;bad_skew&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">list</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="nb">float</span><span class="p">]</span>  <span class="c1"># list of bad cell skew values</span>
 <span class="p">}</span>
</pre></div>
</div>
</p>
</td>
</tr>
</tbody>
</table>
<p>Respective <cite>bad_cells</cite> and <cite>bad_skew</cite> lists entries correspond
to the same cells.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.heal_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">heal_grid</code><span class="sig-paren">(</span><em>gid</em>, <em>simplify_boundary=30</em>, <em>convex_cells=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.heal_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Set of procedures for simplification of grid geometry</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; identifier or (list of identifiers) of the grid</li>
<li><strong>simplify_boundary</strong> (<em>float</em>) &#8211; angle (deg) in [0, 180].</li>
<li><strong>convex_cells</strong> (<em>float</em>) &#8211; angle (deg) in [0, 360]. Maximum
allowed angle in a non-triangle cell.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p>If <strong>simplify_boundary</strong> parameter is non-negative then edges which</p>
<ul class="simple">
<li>are boundary,</li>
<li>belong to the same grid cell,</li>
<li>form an angle no more then <code class="docutils literal"><span class="pre">simplify_boundary</span></code> degree,</li>
</ul>
<p>will be merged if possible. If <code class="docutils literal"><span class="pre">simplify_boundary=0</span></code> then only edges
lying on the same line are considered, <code class="docutils literal"><span class="pre">simplify_boundary=180</span></code>
leads to merging of all doubled boundary edges,
<code class="docutils literal"><span class="pre">simplify_boundary=-1</span></code> ignores this simplification option.</p>
<p>if <strong>convex_cells</strong> is non negative than all cells which provide
angles greater or equal to this value will be splitted.
If <code class="docutils literal"><span class="pre">convex_cells=180</span></code> then all concave cells includings those
whith hanging nodes will be processed.
If you set <code class="docutils literal"><span class="pre">convex_cells=0</span></code> then all cells will be splitted
up to triangles.</p>
<p>Subprocedures order is:</p>
<ul class="simple">
<li>boundary simplification</li>
<li>remove concave cells</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_unf_rect_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_unf_rect_grid</code><span class="sig-paren">(</span><em>p0=[0, 0], p1=[1, 1], nx=3, ny=3, custom_x=[], custom_y=[], bnd=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_unf_rect_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds rectangular grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> (<em>list-of-floats</em>) &#8211; </li>
<li><strong>p1</strong> (<em>list-of-floats</em>) &#8211; bottom left, top right points in [x, y] format.</li>
<li><strong>nx</strong> (<em>int</em>) &#8211; </li>
<li><strong>ny</strong> (<em>int</em>) &#8211; partition in x and y directions.</li>
<li><strong>custom_x</strong> (<em>float-or-list-of-floats</em>) &#8211; </li>
<li><strong>custom_y</strong> (<em>float-or-list-of-floats</em>) &#8211; custom x and y coordinates</li>
<li><strong>int-or-list-of-int</strong> &#8211; boundary types for bottom, right, top, left
rectangle sides</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">created grid identifier</p>
</td>
</tr>
</tbody>
</table>
<p>Builds a grid in a rectangular area formed by points <strong>p0</strong> and <strong>p1</strong>.
<strong>nx</strong> and <strong>ny</strong> provide grid partition in x and y direction.</p>
<p>If <strong>custom_x</strong>/<strong>custom_y</strong> is given by a single float value
than it shows a step size in respective direction,
hence values given by <strong>nx</strong>/<strong>ny</strong> parameters will be omitted.</p>
<p>If <strong>custom_x</strong>/<strong>custom_y</strong> is given by a list of increasing floats
it explicitly shows the partition in respective direction.
In the latter case the respective <strong>p0</strong>, <strong>p1</strong> coordinates
will also be ignored.</p>
<p>Use <a class="reference internal" href="#hybmeshpack.hmscript.partition_segment" title="hybmeshpack.hmscript.partition_segment"><code class="xref py py-func docutils literal"><span class="pre">partition_segment()</span></code></a> to conveniently define <strong>custom_</strong> fields
if needed.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_unf_circ_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_unf_circ_grid</code><span class="sig-paren">(</span><em>p0</em>, <em>rad=1.0</em>, <em>na=8</em>, <em>nr=4</em>, <em>coef=1.0</em>, <em>is_trian=True</em>, <em>custom_rads=[]</em>, <em>custom_arcs=[]</em>, <em>bnd=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_unf_circ_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds circular grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> (<em>list-of-floats</em>) &#8211; center coordinate as [x, y]</li>
<li><strong>rad</strong> (<em>float</em>) &#8211; radius</li>
<li><strong>na</strong> (<em>int</em>) &#8211; </li>
<li><strong>nr</strong> (<em>int</em>) &#8211; partitions of arc and radius respectively</li>
<li><strong>coef</strong> (<em>float</em>) &#8211; refinement coefficient:
* <code class="docutils literal"><span class="pre">coef</span> <span class="pre">=</span> <span class="pre">1</span></code>: equidistant radius division
* <code class="docutils literal"><span class="pre">coef</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>: refinement towards center of circle
* <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">coef</span> <span class="pre">&lt;</span> <span class="pre">1</span></code>: refinement towards outer arc</li>
<li><strong>is_trian</strong> (<em>bool</em>) &#8211; True if center cell should be triangulated</li>
<li><strong>custom_rads</strong> (<em>float-or-list-of-floats</em>) &#8211; user defined radious partition</li>
<li><strong>custom_arcs</strong> (<em>float-or-list-of-floats</em>) &#8211; user defined arc partition</li>
<li><strong>bnd</strong> (<em>int</em>) &#8211; boundary type for outer contour</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">created grid identifier</p>
</td>
</tr>
</tbody>
</table>
<p>Creates a radial grid with the center in <strong>p0</strong>.</p>
<p>If <strong>custom_rads</strong> is given as a single value it will be used
as a constant step along radial axis hence <strong>nr</strong> and <strong>coef</strong> arguments
will be ignored. If it is given as a list of increasing values
starting from zero
then it is parsed as explicit radius partition. Hence the
last entry of this list will be the radius of the resulting grid
and <strong>rad</strong> parameter will also be ignored.</p>
<p>If <strong>custom_arcs</strong> is given as a single value it shows the
constant step along outer arc and <strong>na</strong> will be ignored.
If it is an increasing list of floats, it shows partition of
outer arc. It can be given in degrees or radians or any other
relative units. Program treats <strong>custom_arcs[-1]</strong>-<strong>custom_arcs[0]</strong>
difference as a full circle length and normalizes all other entries
to this length. First and last entries of this array provides
the same arc segment (last = first + 2*pi) hence to
get partition of n segments you should define n+1 entries.</p>
<p>Use <a class="reference internal" href="#hybmeshpack.hmscript.partition_segment" title="hybmeshpack.hmscript.partition_segment"><code class="xref py py-func docutils literal"><span class="pre">partition_segment()</span></code></a> to conveniently define <strong>custom_</strong> fields
if needed.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_unf_ring_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_unf_ring_grid</code><span class="sig-paren">(</span><em>p0</em>, <em>radinner</em>, <em>radouter</em>, <em>na</em>, <em>nr</em>, <em>coef=1.0</em>, <em>bnd=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_unf_ring_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds ring grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> (<em>list-of-floats</em>) &#8211; center coordinates as [x, y]</li>
<li><strong>radinner</strong> (<em>float</em>) &#8211; </li>
<li><strong>radouter</strong> (<em>float</em>) &#8211; inner and outer radii</li>
<li><strong>na</strong> (<em>int</em>) &#8211; </li>
<li><strong>nr</strong> (<em>int</em>) &#8211; arc and radius partition respectively</li>
<li><strong>coef</strong> (<em>float</em>) &#8211; refinement coefficient:
* <code class="docutils literal"><span class="pre">coef</span> <span class="pre">=</span> <span class="pre">1</span></code>: equidistant radius division
* <code class="docutils literal"><span class="pre">coef</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>: refinement towards center of circle
* <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">coef</span> <span class="pre">&lt;</span> <span class="pre">1</span></code>: refinement towards outer arc</li>
<li><strong>bnd</strong> (<em>int-or-list-of-int</em>) &#8211; boundary types for inner and outer
ring boundaries</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">created grid identifier</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_unf_hex_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_unf_hex_grid</code><span class="sig-paren">(</span><em>area</em>, <em>cell_radius</em>, <em>strict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_unf_hex_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds grid with regular hexagonal cells</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>area</strong> &#8211; defines meshing area. If given as <code class="docutils literal"><span class="pre">[[x,</span> <span class="pre">y],</span> <span class="pre">radius]</span></code>
then represents hexagonal area; if <code class="docutils literal"><span class="pre">[[x0,</span> <span class="pre">y0],</span> <span class="pre">[x1,</span> <span class="pre">y1]]</span></code> then
it is a rectangle defined by bottom-left and top-right points.</li>
<li><strong>cell_radius</strong> (<em>float</em>) &#8211; radius of hexagonal cell.</li>
<li><strong>strict</strong> (<em>bool</em>) &#8211; forces grid stretch
to guarantee that all outer rectangle corners lie in the
centers of cells.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>See details in <a class="reference internal" href="prototypes.html#hexgrid"><span class="std std-ref">Hexagonal grid</span></a></p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_triangle_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_triangle_grid</code><span class="sig-paren">(</span><em>p0</em>, <em>p1</em>, <em>p2</em>, <em>nedge</em>, <em>bnd=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_triangle_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates structured grid in triangle area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> (<em>list-of-floats</em>) &#8211; </li>
<li><strong>p1</strong> (<em>list-of-floats</em>) &#8211; </li>
<li><strong>p2</strong> (<em>list-of-floats</em>) &#8211; triangle vertices in [x, y] format</li>
<li><strong>nedge</strong> (<em>int</em>) &#8211; partition of triangle edges</li>
<li><strong>bnd</strong> (<em>int-or-list-of-int</em>) &#8211; boundary types for outer contour</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">identifier of newly created grid</p>
</td>
</tr>
</tbody>
</table>
<p>Resulting grid will contain quadrangle cells everywhere except
area near <code class="docutils literal"><span class="pre">p0</span></code>-<code class="docutils literal"><span class="pre">p2</span></code> edge where triangle cells will be built.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_custom_rect_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_custom_rect_grid</code><span class="sig-paren">(</span><em>algo, left, bottom, right=None, top=None, hermite_tfi_w=[1.0, 1.0, 1.0, 1.0], return_invalid=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_custom_rect_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates rectangular grid on the basis of four curvilinear contours
using contour vertices for partition.
See details in <a class="reference internal" href="prototypes.html#custom-rect-grid"><span class="std std-ref">Custom Rectangle Grid</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>algo</strong> (<em>str</em>) &#8211; <p>Algorithms of building:</p>
<ul>
<li><code class="docutils literal"><span class="pre">'linear'</span></code> - connects respective points of opposite
contours by straight lines.</li>
<li><code class="docutils literal"><span class="pre">'linear_tfi'</span></code> - linear transfinite interpolation</li>
<li><code class="docutils literal"><span class="pre">'hermite_tfi'</span></code> - hermite transfinite interpolation</li>
<li><code class="docutils literal"><span class="pre">'inverse_laplace'</span></code> -</li>
<li><code class="docutils literal"><span class="pre">'direct_laplace'</span></code> - connects points using solution of
laplace equation with Dirichlet boundary conditions;</li>
<li><code class="docutils literal"><span class="pre">'orthogonal'</span></code> - builds orthogonal grid based on <strong>left</strong> and
<strong>bottom</strong> partition.
Partitions of <strong>right</strong> and <strong>top</strong> are ignored.</li>
</ul>
</li>
<li><strong>left</strong> &#8211; </li>
<li><strong>bottom</strong> &#8211; </li>
<li><strong>right</strong> &#8211; </li>
<li><strong>top</strong> &#8211; identifiers of curvilinear domain sides.
<strong>right</strong> and <strong>top</strong> could be <code class="docutils literal"><span class="pre">None</span></code>. If so right and top
boundaries will be created by translation of <strong>left</strong> and <strong>bottom</strong>.</li>
<li><strong>hermite_tfi_w</strong> (<em>list-of-floats</em>) &#8211; perpendicularity weights
for <strong>left</strong>, <strong>bottom</strong>, <strong>right</strong>, <strong>top</strong> contours respectively
for <strong>algo</strong> = <code class="docutils literal"><span class="pre">'hermite_tfi'</span></code></li>
<li><strong>return_invalid</strong> (<em>bool</em>) &#8211; <p>if this flag is on
then the procedure will return a grid even if it is not valid
(has self-intersections). Such grids could be exported to
simple formats (like vtk or tecplot) in order to detect
bad regions and give user a hint of how to adopt
input data to gain an acceptable result.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Never use invalid grids for further operations.</p>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">new grid identifier</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.add_circ_rect_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">add_circ_rect_grid</code><span class="sig-paren">(</span><em>p0</em>, <em>rad</em>, <em>step</em>, <em>sqrside=1.0</em>, <em>rcoef=1.0</em>, <em>algo='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.add_circ_rect_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates quadrangular cell grid in a circular area.
See details in <a class="reference internal" href="prototypes.html#circrect-grid"><span class="std std-ref">Square in Circle</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> (<em>list-of-floats</em>) &#8211; center point of circle area in [x, y] format.</li>
<li><strong>rad</strong> (<em>positive-float</em>) &#8211; radius of circle area.</li>
<li><strong>step</strong> (<em>positive-float</em>) &#8211; approximate partition step of the outer
boundary.</li>
<li><strong>sqrside</strong> (<em>positive-float</em>) &#8211; side of the inner square normalized by
the circle radius. Values greater than 1.4 are not allowed.</li>
<li><strong>rcoef</strong> (<em>positive-float</em>) &#8211; radius direction refinement of
the ring part of the grid.
Values less then unity lead to refinement towards outer boundary.</li>
<li><strong>algo</strong> (<em>str</em>) &#8211; <p>Algorithms of assembling the ring part of the grid.</p>
<ul>
<li><code class="docutils literal"><span class="pre">'linear'</span></code> - use weighted approach for each ray partition</li>
<li><code class="docutils literal"><span class="pre">'laplace'</span></code> - use algebraic mapping for
building each 45 degree sector.</li>
<li><code class="docutils literal"><span class="pre">'orthogonal_circ'</span></code> - build orthogonal grid keeping
uniform grid at outer circle</li>
<li><code class="docutils literal"><span class="pre">'orthogonal_rect'</span></code> - build orthogonal grid keeping
uniform grid at inner rectangle</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">new grid identifier</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.stripe">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">stripe</code><span class="sig-paren">(</span><em>cont</em>, <em>partition</em>, <em>tip='no'</em>, <em>bnd=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.stripe" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a structured grid to the both sides of contour line</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cont</strong> &#8211; closed or open contour identifier</li>
<li><strong>partition</strong> (<em>ascending-list-of-double</em>) &#8211; partition perpendicular
to source contour</li>
<li><strong>tip</strong> (<em>str</em>) &#8211; <p>stripe endings meshing algorithm</p>
<ul>
<li><code class="docutils literal"><span class="pre">&quot;no&quot;</span></code> - no grid at endings</li>
<li><code class="docutils literal"><span class="pre">&quot;radial&quot;</span></code> - radial grid at endings</li>
</ul>
</li>
<li><strong>bnd</strong> (<em>float-or-list-of-floats</em>) &#8211; boundary types for input grid.
List of four values provides respective values for bottom, left,
right, top sides of resulting grid with respect to contour direction.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid identifier</p>
</td>
</tr>
</tbody>
</table>
<p>Horizontal partition is taken from contour partition.
Vertical partition is given by user with <code class="docutils literal"><span class="pre">partition</span></code> list parameter.
If it starts with non zero value then grid will not contain
contour nodes as its vertices.</p>
<p>Use <a class="reference internal" href="#hybmeshpack.hmscript.partition_segment" title="hybmeshpack.hmscript.partition_segment"><code class="xref py py-func docutils literal"><span class="pre">partition_segment()</span></code></a> to define non-equidistant
<strong>partition</strong> with any desired refinement if needed.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.triangulate_domain">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">triangulate_domain</code><span class="sig-paren">(</span><em>domain</em>, <em>constr=[]</em>, <em>pts=[]</em>, <em>fill='3'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.triangulate_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds constrained triangulation within given domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>domain</strong> &#8211; single or list of closed contours
representing bounding domain</li>
<li><strong>constr</strong> &#8211; single or list of contours representing
triangulation constraints</li>
<li><strong>pts</strong> &#8211; set of points in <code class="docutils literal"><span class="pre">[len0,</span> <span class="pre">[x0,</span> <span class="pre">y0],</span> <span class="pre">...]</span></code>
format where <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></code> are coordinates of internal vertices
which should be embedded into the resulting grid,
<code class="docutils literal"><span class="pre">len</span></code> - size of adjacent cells</li>
<li><strong>fill</strong> (<em>str</em>) &#8211; if &#8216;3&#8217; then triangulates area; &#8216;4&#8217; runs
recombination algorithm to make mostly quadrangular mesh</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid identifier</p>
</td>
</tr>
</tbody>
</table>
<p>A contour tree will be built using all closed contours
passed as <strong>domain</strong> parameter. Only the interior parts
of this tree will be meshed. Contours passed by <strong>domain</strong>
should not intersect each other, but could intersect <strong>constr</strong>
contours.
<strong>constr</strong> could contain any set of closed and open contours.</p>
<p>See details in <a class="reference internal" href="functionality.html#unstructured-meshing"><span class="std std-ref">Unstructured Domain Meshing</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.pebi_fill">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">pebi_fill</code><span class="sig-paren">(</span><em>domain</em>, <em>constr=[]</em>, <em>pts=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.pebi_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds perpendicular bisector cells in given domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>domain</strong> &#8211; single or list of closed contours
representing bounding domain</li>
<li><strong>constr</strong> &#8211; single or list of contours representing
meshing constraints</li>
<li><strong>pts</strong> &#8211; set of points in <code class="docutils literal"><span class="pre">[len0,</span> <span class="pre">[x0,</span> <span class="pre">y0],</span> <span class="pre">...]</span></code>
format where <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></code> are coordinates of internal vertices
which should be embedded into the resulting grid,
<code class="docutils literal"><span class="pre">len</span></code> - size of adjacent cells</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid identifier</p>
</td>
</tr>
</tbody>
</table>
<p>A contour tree will be built using all closed contours
passed as <strong>domain</strong> parameter. Only the interior parts
of this tree will be meshed. Contours passed by <strong>domain</strong>
should not intersect each other, but could intersect <strong>constr</strong>
contours.</p>
<p>Routine can produce concave cells (as a result of bad size
control or near the concave domain boundary vertices).
Use <a class="reference internal" href="#hybmeshpack.hmscript.heal_grid" title="hybmeshpack.hmscript.heal_grid"><code class="xref py py-func docutils literal"><span class="pre">heal_grid()</span></code></a> routine with <code class="docutils literal"><span class="pre">convex_cells</span></code> option to fix this.</p>
<p>See details in <a class="reference internal" href="functionality.html#unstructured-meshing"><span class="std std-ref">Unstructured Domain Meshing</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.unite_grids">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">unite_grids</code><span class="sig-paren">(</span><em>base_grid</em>, <em>over_grids</em>, <em>empty_holes=False</em>, <em>fix_bnd=False</em>, <em>zero_angle_approx=0</em>, <em>buffer_fill='3'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.unite_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes grids superposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>base_grid</strong> &#8211; basic grid identifier</li>
<li><strong>over_grids</strong> (<em>list-of-tuples</em>) &#8211; sequence of grids for superposition as
<code class="docutils literal"><span class="pre">[(grid_id,</span> <span class="pre">buffer),</span> <span class="pre">()</span> <span class="pre">...]</span></code> where
<code class="docutils literal"><span class="pre">grid_id</span></code> is an superposed grid identifier,
<code class="docutils literal"><span class="pre">buffer</span></code> - size of the buffer for current union</li>
<li><strong>empty_holes</strong> (<em>bool</em>) &#8211; keep all empty zones
(in case of multiple connectivity)
of imposed grids in the resulting grid.</li>
<li><strong>fix_bnd</strong> (<em>bool</em>) &#8211; whether to fix all boundary nodes</li>
<li><strong>zero_angle_approx</strong> (<em>positive-degree</em>) &#8211; defines deviation from the straight angle which is considered
insignificant. Grid boundary vertices which provide insignificant
contour turns could be moved in order to obtain better result.
Makes sense only if <code class="docutils literal"><span class="pre">fix_bnd</span> <span class="pre">=</span> <span class="pre">False</span></code>.</li>
<li><strong>buffer_fill</strong> (<em>str</em>) &#8211; <p>type of grid in a buffer.</p>
<ul>
<li><code class="docutils literal"><span class="pre">&quot;3&quot;</span></code> - triangle grid</li>
<li><code class="docutils literal"><span class="pre">&quot;4&quot;</span></code> - mostly quadrangle grid</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">identifier of the newly created grid</p>
</td>
</tr>
</tbody>
</table>
<p>See detailed options description in <a class="reference internal" href="functionality.html#gridimp"><span class="std std-ref">Grid Superposition</span></a>.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span>
<span class="c1"># lower level grid</span>
<span class="n">g1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_unf_rect_grid</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1"># first imposition grid</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_unf_rect_grid</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1"># second imposition grid</span>
<span class="n">g3</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_unf_circ_grid</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1"># impose grids</span>
<span class="n">impgrid</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">unite_grids</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="p">[(</span><span class="n">g2</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">),</span> <span class="p">(</span><span class="n">g3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)])</span>

</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.unite_grids1">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">unite_grids1</code><span class="sig-paren">(</span><em>base_grid</em>, <em>secondary_grid</em>, <em>buffer_size</em>, <em>empty_holes=False</em>, <em>fix_bnd=False</em>, <em>zero_angle_approx=0</em>, <em>buffer_fill='3'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.unite_grids1" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes superposition of two grids.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>base_grid</strong> &#8211; basic grid identifier</li>
<li><strong>secondary_grid</strong> &#8211; superposed grid identifier</li>
<li><strong>buffer_size</strong> (<em>float</em>) &#8211; size of the buffer zone</li>
<li><strong>empty_holes</strong> (<em>bool</em>) &#8211; keep all empty zones
(in case of multiple connectivity)
of imposed grids in the resulting grid.</li>
<li><strong>fix_bnd</strong> (<em>bool</em>) &#8211; whether to fix all boundary nodes</li>
<li><strong>zero_angle_approx</strong> (<em>positive-degree</em>) &#8211; defines deviation from the straight angle which is considered
insignificant. Grid boundary vertices which provide insignificant
contour turns could be moved in order to obtain better result.
Makes sense only if <code class="docutils literal"><span class="pre">fix_bnd</span> <span class="pre">=</span> <span class="pre">False</span></code>.</li>
<li><strong>buffer_fill</strong> (<em>str</em>) &#8211; <p>type of grid in a buffer.</p>
<ul>
<li><code class="docutils literal"><span class="pre">&quot;3&quot;</span></code> - triangle grid</li>
<li><code class="docutils literal"><span class="pre">&quot;4&quot;</span></code> - mostly quadrangle grid</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">identifier of the newly created grid</p>
</td>
</tr>
</tbody>
</table>
<p>Same as <a class="reference internal" href="#hybmeshpack.hmscript.unite_grids" title="hybmeshpack.hmscript.unite_grids"><code class="xref py py-func docutils literal"><span class="pre">unite_grids()</span></code></a> without chain superposition support.</p>
</dd></dl>

<dl class="class">
<dt id="hybmeshpack.hmscript.BoundaryGridOptions">
<em class="property">class </em><code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">BoundaryGridOptions</code><a class="headerlink" href="#hybmeshpack.hmscript.BoundaryGridOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Options for building boundary grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>contour_id</strong> &#8211; identifier of input source contour</li>
<li><strong>partition</strong> (<em>list-of-floats</em>) &#8211; partition in perpendicular direction.
List of ascending floats starting from zero which
represents distances from contour to grid layers</li>
<li><strong>direction</strong> (<em>str</em>) &#8211; &#8216;left&#8217;/&#8217;right&#8217;. Boundary grid will be built to the left/right
from the contour (with respect to positive tracing)</li>
<li><strong>bnd_step</strong> (<em>float</em>) &#8211; float size of artificial stepping along the contour (used only if
<code class="docutils literal"><span class="pre">bnd_stepping</span></code> is not &#8220;no&#8221;). If <code class="docutils literal"><span class="pre">bnd_stepping</span> <span class="pre">==</span> <span class="pre">'incremental'</span></code> then
this should be a list of two floats: boundary partition nearby start
and end of the contour</li>
<li><strong>bnd_stepping</strong> (<em>str</em>) &#8211; <p>algorithm for stepping along the contour</p>
<ul>
<li><code class="docutils literal"><span class="pre">'no'</span></code>: no artificial stepping. Only contour vertices will
be used as grid nodes</li>
<li><code class="docutils literal"><span class="pre">'const'</span></code>: use only artificial stepping and ignore contour
vertices</li>
<li><code class="docutils literal"><span class="pre">'keep_shape'</span></code>: use stepping and keep significant
contour vertices</li>
<li><code class="docutils literal"><span class="pre">'keep_all'</span></code>: use stepping and keep all contour vertices</li>
<li><code class="docutils literal"><span class="pre">'incremental'</span></code>: increase boundary step linearly from <code class="docutils literal"><span class="pre">start_point</span></code>
to <code class="docutils literal"><span class="pre">end_point</span></code>. Valid only for open contours
<code class="docutils literal"><span class="pre">start_point</span></code> != <code class="docutils literal"><span class="pre">end_point</span></code>. It acts like <code class="docutils literal"><span class="pre">const</span></code> stepping:
no initial boundary vertices will be saved.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While using <code class="docutils literal"><span class="pre">const</span></code> boundary step resulting grid may contain
boundary edges with intermediate nodes. They are placed there
intentionally to make further grid union operations easier.
To get rid of such nodes use <a class="reference internal" href="#hybmeshpack.hmscript.heal_grid" title="hybmeshpack.hmscript.heal_grid"><code class="xref py py-func docutils literal"><span class="pre">heal_grid()</span></code></a> with
<code class="docutils literal"><span class="pre">simplify_boundary</span></code> option at the very end of grid creation
(see <a class="reference internal" href="intro_example3.html#example3"><span class="std std-ref">Example 3</span></a> for example of elimination of those nodes).</p>
</div>
</li>
<li><strong>range_angles</strong> (<em>list-of-floats</em>) &#8211; <p>list of 4 angle values (deg) which define algorithms
for contour bends treatment:</p>
<ul>
<li><code class="docutils literal"><span class="pre">[0,</span>&#160;&#160;&#160;&#160; <span class="pre">ra[0]]</span></code>: acute angle algorithm</li>
<li><code class="docutils literal"><span class="pre">[ra[0],</span> <span class="pre">ra[1]]</span></code>: right angle algorithm</li>
<li><code class="docutils literal"><span class="pre">[ra[1],</span> <span class="pre">ra[2]]</span></code>: straight angle algorithm</li>
<li><code class="docutils literal"><span class="pre">[ra[2],</span> <span class="pre">ra[3]]</span></code>: reentrant angle algorithm</li>
<li><code class="docutils literal"><span class="pre">[ra[3],</span>&#160;&#160; <span class="pre">360]</span></code>: round algorithm</li>
</ul>
</li>
<li><strong>force_conformal</strong> (<em>bool</em>) &#8211; use strictly conformal mappings</li>
<li><strong>start_point</strong><strong>, </strong><strong>end_point</strong> (<em>list-of-floats</em>) &#8211; points in [x, y] format which define
the exact segment of the contour for building grid.
If both are None hence whole contour (or all subcontours) will be used.
if <code class="docutils literal"><span class="pre">start_point</span></code> == <code class="docutils literal"><span class="pre">end_point</span></code> then whole subcontour closest to
this point will be used.
If point is not located on the source contour then it will be
projected to it.</li>
<li><strong>project_to</strong> (<em>str</em>) &#8211; <p>option which defines <strong>start_point</strong>, <strong>end_point</strong> projection algorithm:</p>
<ul>
<li><code class="docutils literal"><span class="pre">&quot;line&quot;</span></code> - projects point to source contour line,</li>
<li><code class="docutils literal"><span class="pre">&quot;vertex&quot;</span></code> - projects to closest source contour vertex,</li>
<li><code class="docutils literal"><span class="pre">&quot;corner&quot;</span></code> - projects point to closest corner vertex.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Class contains functions to define uniform and increasing
vertical partitions. However user could give his own custom partition by
explicit assigning of <strong>partition</strong> attribute.
Use <a class="reference internal" href="#hybmeshpack.hmscript.partition_segment" title="hybmeshpack.hmscript.partition_segment"><code class="xref py py-func docutils literal"><span class="pre">partition_segment()</span></code></a> for advanced control of vertical
partition.</p>
<dl class="method">
<dt id="hybmeshpack.hmscript.BoundaryGridOptions.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>contour_id=None, partition=[0], direction='left', bnd_step=0.1, bnd_stepping='keep_shape', range_angles=[40, 125, 235, 275], force_conformal=False, start_point=None, end_point=None, project_to='line'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.BoundaryGridOptions.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor with default attributes values given</p>
</dd></dl>

<dl class="method">
<dt id="hybmeshpack.hmscript.BoundaryGridOptions.incremental_partition">
<code class="descname">incremental_partition</code><span class="sig-paren">(</span><em>h0</em>, <em>coef</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.BoundaryGridOptions.incremental_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets incremental boundary grid vertical <cite>partition</cite>
starting from <code class="docutils literal"><span class="pre">h0</span></code>, with each next step is <code class="docutils literal"><span class="pre">coef</span></code> times
bigger then the previous. Total of <code class="docutils literal"><span class="pre">n</span></code> layers will be built</p>
</dd></dl>

<dl class="method">
<dt id="hybmeshpack.hmscript.BoundaryGridOptions.uniform_partition">
<code class="descname">uniform_partition</code><span class="sig-paren">(</span><em>fullh</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.BoundaryGridOptions.uniform_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets uniform boundary grid vertical <cite>partition</cite> with
the full depth of <code class="docutils literal"><span class="pre">fullh</span></code> and <code class="docutils literal"><span class="pre">n</span></code> total layers</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.build_boundary_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">build_boundary_grid</code><span class="sig-paren">(</span><em>opts</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.build_boundary_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a boundary grid near contour</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Params opts:</th><td class="field-body">single or list of <a class="reference internal" href="#hybmeshpack.hmscript.BoundaryGridOptions" title="hybmeshpack.hmscript.BoundaryGridOptions"><code class="xref py py-class docutils literal"><span class="pre">BoundaryGridOptions</span></code></a> objects</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">identifier of the newly created grid.</td>
</tr>
</tbody>
</table>
<p>If different options for different segments of the contour are required
(e.g. different partitions) then multiple option instances with the same
target contour should be passed.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><p class="first">this code
creates boundary grid along a square with different settings
for vertical and horizontal edges of the source square:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="c1"># create source contour for a boundary grid</span>
<span class="n">cont</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_rect_contour</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="c1"># basic options for horizontal segments</span>
<span class="c1"># using default direction=&quot;left&quot; to build grid inside the source contour</span>
<span class="n">opvert</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">BoundaryGridOptions</span><span class="p">(</span>
    <span class="n">cont</span><span class="p">,</span>
    <span class="n">partition</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">],</span>
    <span class="n">bnd_step</span><span class="o">=</span><span class="mf">0.06</span><span class="p">)</span>
<span class="c1"># basic options for vertical segments</span>
<span class="c1"># It differs from horizontal segments by cross and lengthwise</span>
<span class="c1"># boundary grid partition</span>
<span class="n">ophoriz</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">BoundaryGridOptions</span><span class="p">(</span>
    <span class="n">cont</span><span class="p">,</span>
    <span class="n">partition</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
    <span class="n">bnd_step</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>
<span class="c1"># option for bottom segment. Using deepcopy so that changes in one</span>
<span class="c1"># inctance do not affect the others.</span>
<span class="n">op1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ophoriz</span><span class="p">)</span>
<span class="n">op1</span><span class="o">.</span><span class="n">start_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">op1</span><span class="o">.</span><span class="n">end_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1"># option for left segment</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">opvert</span><span class="p">)</span>
<span class="n">op2</span><span class="o">.</span><span class="n">start_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">op2</span><span class="o">.</span><span class="n">end_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="c1"># option for top segment</span>
<span class="n">op3</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ophoriz</span><span class="p">)</span>
<span class="n">op3</span><span class="o">.</span><span class="n">start_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">op3</span><span class="o">.</span><span class="n">end_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="c1"># option for right segment</span>
<span class="n">op4</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">opvert</span><span class="p">)</span>
<span class="n">op4</span><span class="o">.</span><span class="n">start_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">op4</span><span class="o">.</span><span class="n">end_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1"># building boundary grid</span>
<span class="n">bgrid</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">build_boundary_grid</span><span class="p">([</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">op3</span><span class="p">,</span> <span class="n">op4</span><span class="p">])</span>

</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.build_boundary_grid1">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">build_boundary_grid1</code><span class="sig-paren">(</span><em>cont, partition, direction, pstart=None, pend=None, range_angles=[40, 125, 235, 275]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.build_boundary_grid1" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a singly-connected boundary grid near given contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cont</strong> &#8211; source contour (or grid) identifier</li>
<li><strong>partition</strong> (<em>list-of-float</em>) &#8211; partition in perpendicular direction.</li>
<li><strong>direction</strong> (<em>str</em>) &#8211; &#8216;left&#8217;/&#8217;right&#8217;</li>
<li><strong>pstart</strong> &#8211; </li>
<li><strong>pend</strong> &#8211; points in [x, y] format which define
the exact segment of the contour for building grid.
If both are None hence whole contour (or all subcontours) will be used.</li>
<li><strong>range_angles</strong> &#8211; list of 4 angle values (deg) which define algorithms
for contour bends treatment.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">identifier of the newly created grid.</p>
</td>
</tr>
</tbody>
</table>
<p>This is a wrapper for a <a class="reference internal" href="#hybmeshpack.hmscript.build_boundary_grid" title="hybmeshpack.hmscript.build_boundary_grid"><code class="xref py py-func docutils literal"><span class="pre">build_boundary_grid()</span></code></a> with simplified
interface. It allows to build a boundary grid with constant partition
options using existing contour segmentation for horizontal stepping.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.exclude_contours">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">exclude_contours</code><span class="sig-paren">(</span><em>grid</em>, <em>conts</em>, <em>what</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.exclude_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a grid by excluding contour area from existing grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grid</strong> &#8211; source grid identifier</li>
<li><strong>conts</strong> &#8211; contour or list of contours/grids identifiers for exclusion.</li>
<li><strong>what</strong> (<em>str</em>) &#8211; <code class="docutils literal"><span class="pre">&quot;inner&quot;</span></code>/<code class="docutils literal"><span class="pre">&quot;outer&quot;</span></code>.
Describes what part of <code class="docutils literal"><span class="pre">conts</span></code> domain exclude</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">new grid identifier</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All contours from <strong>cont</strong> list are excluded consecutively.
If you want to exclude multiply connected domain area you should first
assemble multiply connected domain from the list of singly
connected ones using <a class="reference internal" href="#hybmeshpack.hmscript.unite_contours" title="hybmeshpack.hmscript.unite_contours"><code class="xref py py-func docutils literal"><span class="pre">unite_contours()</span></code></a> procedure.</p>
</div>
<dl class="docutils">
<dt>Example:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span>
<span class="c1"># source grid: circle with diameter = 5</span>
<span class="n">g1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_unf_circ_grid</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1"># outer domain border: square with edge length = 8</span>
<span class="n">c1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_rect_contour</span><span class="p">([</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="c1"># inner domain border: triangle within c1</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">create_contour</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]])</span>
<span class="c1"># multiply connected domain</span>
<span class="n">c3</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">unite_contours</span><span class="p">([</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">])</span>
<span class="c1"># exclusion</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">exclude_contours</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">)</span>

</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.map_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">map_grid</code><span class="sig-paren">(</span><em>base_grid</em>, <em>target_contour</em>, <em>base_points</em>, <em>target_points</em>, <em>snap='no'</em>, <em>project_to='line'</em>, <em>btypes='from_grid'</em>, <em>algo='inverse_laplace'</em>, <em>is_reversed=False</em>, <em>return_invalid=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.map_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs mapping of base grid on another contour.
See detailed options description in <a class="reference internal" href="functionality.html#gridmappings"><span class="std std-ref">Grid Mapping</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>base_grid</strong> &#8211; grid identifier.</li>
<li><strong>target_contour</strong> &#8211; contour identifier.</li>
<li><strong>base_points</strong> &#8211; collection of points in <code class="docutils literal"><span class="pre">[[x0,</span> <span class="pre">y0],</span> <span class="pre">[x1,</span> <span class="pre">y1],</span> <span class="pre">...]</span></code>
format which lie on the <strong>base_grid</strong> contour (if a point doesn&#8217;t lie on
contour it would be projected to it).</li>
<li><strong>target_points</strong> &#8211; collection of points in <code class="docutils literal"><span class="pre">[[x0,</span> <span class="pre">y0],</span> <span class="pre">[x1,</span> <span class="pre">y1],</span> <span class="pre">...]</span></code>
format which lie on the <strong>target_contour</strong>.
The i-th point of <strong>target_points</strong> will be mapped into i-th point of
<strong>contour_points</strong>.</li>
<li><strong>snap</strong> (<em>str</em>) &#8211; <p>an option which defines post processing algorithm of snapping
newly created grid to <em>target_contour</em>:</p>
<ul>
<li><code class="docutils literal"><span class="pre">&quot;no&quot;</span></code> - no snapping</li>
<li><code class="docutils literal"><span class="pre">&quot;add_vertices&quot;</span></code> - snap by adding new vertices if that will not
ruin grid topology</li>
<li><code class="docutils literal"><span class="pre">&quot;shift_vertices&quot;</span></code> - shift non-corner boundary nodes to corner
locations if possible</li>
</ul>
</li>
<li><strong>project_to</strong> (<em>str</em>) &#8211; <p>option which defines <strong>target_points</strong> and <strong>base_points</strong>
projection algorithm:</p>
<ul>
<li><code class="docutils literal"><span class="pre">&quot;line&quot;</span></code> - projects point to source contour line,</li>
<li><code class="docutils literal"><span class="pre">&quot;vertex&quot;</span></code> - projects to closest source contour vertex,</li>
<li><code class="docutils literal"><span class="pre">&quot;corner&quot;</span></code> - projects point to closest corner vertex.</li>
</ul>
</li>
<li><strong>btypes</strong> (<em>str</em>) &#8211; defines from what source boundary features for newly created grid
would be taken: <code class="docutils literal"><span class="pre">&quot;from_grid&quot;</span></code> or <code class="docutils literal"><span class="pre">&quot;from_contour&quot;</span></code>.</li>
<li><strong>algo</strong> (<em>str</em>) &#8211; <p>defines algorithm of mapping:</p>
<ul>
<li><code class="docutils literal"><span class="pre">&quot;direct_laplace&quot;</span></code> solves Laplace problem in base domain,</li>
<li><code class="docutils literal"><span class="pre">&quot;inverse_laplace&quot;</span></code> solves Laplace problem in target domain.</li>
</ul>
</li>
<li><strong>is_reversed</strong> (<em>bool</em>) &#8211; shows whether target contour
should be treated in reversed order while building boundary mapping.</li>
<li><strong>return_invalid</strong> (<em>bool</em>) &#8211; <p>if this flag is on
then the procedure will return a grid even if it is not valid
(has self-intersections). Such grids could be exported to
simple formats (like vtk or tecplot) in order to detect
bad regions and give user a hint of how to adopt
input data to gain an acceptable result.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Never use invalid grids for further operations.</p>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">identifier of newly created grid</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.snap_grid_to_contour">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">snap_grid_to_contour</code><span class="sig-paren">(</span><em>gid</em>, <em>cid</em>, <em>gstart</em>, <em>gend</em>, <em>cstart</em>, <em>cend</em>, <em>algo='add'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.snap_grid_to_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Snaps grid boundary subsection to contour subsection.
See details in <a class="reference internal" href="functionality.html#snapgrid"><span class="std std-ref">Grid Snapping</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; source grid identifier.</li>
<li><strong>cid</strong> &#8211; target contour identifier.</li>
<li><strong>gstart</strong> &#8211; </li>
<li><strong>gend</strong> &#8211; grid boundary start/end points as <code class="docutils literal"><span class="pre">[x,</span> <span class="pre">y]</span></code>.</li>
<li><strong>cstart</strong> &#8211; </li>
<li><strong>cend</strong> &#8211; contour start/end points as <code class="docutils literal"><span class="pre">[x,</span> <span class="pre">y]</span></code>.</li>
<li><strong>algo</strong> (<em>str</em>) &#8211; <p>Intermediate grid vertices will be:</p>
<ul>
<li><code class="docutils literal"><span class="pre">'add'</span></code> - projected to contour;</li>
<li><code class="docutils literal"><span class="pre">'shift'</span></code> - shifted to closest contour vertices.</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">new grid identifier.</p>
</td>
</tr>
</tbody>
</table>
<p>Given end points will be projected to closest objects vertices.
To define the whole closed contour let start point
be equal to respective end point.</p>
</dd></dl>

</div>
<div class="section" id="id4">
<h2>Surface Operations<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="hybmeshpack.hmscript.info_surface">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">info_surface</code><span class="sig-paren">(</span><em>sid</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.info_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Get surface structure information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sid</strong> &#8211; surface or 3d grid identifier</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dictionary representing total number of nodes, edges, faces,
and number of faces of each boundary type:<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;Nnodes&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;Nedges&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;Nfaces&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;btypes&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">btype</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span> <span class="nb">int</span><span class="p">}</span>  <span class="c1"># boundary type: number of faces</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.tab_surf3">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">tab_surf3</code><span class="sig-paren">(</span><em>obj</em>, <em>what</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.tab_surf3" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns plain table for the given surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>obj</strong> (<em>str</em>) &#8211; surface identifier</li>
<li><strong>what</strong> (<em>str</em>) &#8211; table name</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">plain ctypes array representing requested table.</p>
</td>
</tr>
</tbody>
</table>
<p>Possible <strong>what</strong> values are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'vert'</span></code> - vertex coordinates table,</li>
<li><code class="docutils literal"><span class="pre">'face_center'</span></code> - faces center point coordinates table,</li>
<li><code class="docutils literal"><span class="pre">'edge_vert'</span></code> - edge-vertex connectivity: indices of first and
last vertices for each edge,</li>
<li><code class="docutils literal"><span class="pre">'face_dim'</span></code> - number of vertices in each face,</li>
<li><code class="docutils literal"><span class="pre">'face_edge'</span></code> - face-edge connectivity: ordered list of edge indicies
for each face</li>
<li><code class="docutils literal"><span class="pre">'face_vert'</span></code> - face-vertex connectivity: ordered list of vertex
indices for each face</li>
<li><code class="docutils literal"><span class="pre">'bt'</span></code> - boundary features of each edge.</li>
</ul>
<p>In case of surfaces with variable face dimensions
<code class="docutils literal"><span class="pre">'face_edge'</span></code> and <code class="docutils literal"><span class="pre">'face_vert'</span></code> tables require
additional <code class="docutils literal"><span class="pre">'face_dim'</span></code> table to subdive
returned plain array by certain faces.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.grid3_bnd_to_surface">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">grid3_bnd_to_surface</code><span class="sig-paren">(</span><em>gid</em>, <em>separate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.grid3_bnd_to_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns surface object built out of grid boundary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; 3D grid identifier</li>
<li><strong>separate</strong> (<em>bool</em>) &#8211; whether grid surface should be separated
into singly connected set of surfaces</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid identifier if <strong>separate</strong> is False or
list of grid identifiers otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.domain_volume">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">domain_volume</code><span class="sig-paren">(</span><em>sid</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.domain_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates area of closed domain bounded by the given surface</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sid</strong> &#8211; grid3d or surface identifier</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">positive float or zero for not closed surfaces</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id5">
<h2>3D Grid Operations<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="hybmeshpack.hmscript.info_grid3d">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">info_grid3d</code><span class="sig-paren">(</span><em>gid</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.info_grid3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Get 3d grid structure information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gid</strong> &#8211; 3d grid identifier</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dictionary which represents
total number of nodes, edges, faces, cells:<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;Nnodes&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;Nedges&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;Nfaces&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
 <span class="s1">&#39;Ncells&#39;</span><span class="p">:</span> <span class="nb">int</span>
 <span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.tab_grid3">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">tab_grid3</code><span class="sig-paren">(</span><em>obj</em>, <em>what</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.tab_grid3" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns plain table for the given grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>obj</strong> (<em>str</em>) &#8211; grid identifier</li>
<li><strong>what</strong> (<em>str</em>) &#8211; table name</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">plain ctypes array representing requested table.</p>
</td>
</tr>
</tbody>
</table>
<p>Possible <strong>what</strong> values are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'vert'</span></code> - vertex coordinates table,</li>
<li><code class="docutils literal"><span class="pre">'edge_vert'</span></code> - edge-vertex connectivity: indices of first and
last vertices for each edge,</li>
<li><code class="docutils literal"><span class="pre">'face_dim'</span></code> - number of vertices in each face,</li>
<li><code class="docutils literal"><span class="pre">'face_edge'</span></code> - face-edge connectivity: ordered list of edge indicies
for each face</li>
<li><code class="docutils literal"><span class="pre">'face_vert'</span></code> - face-vertex connectivity: ordered list of vertex
indicies for each face</li>
<li><code class="docutils literal"><span class="pre">'face_cell'</span></code> - face-cell connectivity: indices of left and right
cell for each face. If this is a boundary face <code class="docutils literal"><span class="pre">-1</span></code> is used to mark
boundary side,</li>
<li><code class="docutils literal"><span class="pre">'cell_fdim'</span></code> - number of faces in each cell,</li>
<li><code class="docutils literal"><span class="pre">'cell_vdim'</span></code> - number of vertices in each cell,</li>
<li><code class="docutils literal"><span class="pre">'cell_face'</span></code> - cell-edge connectivity: edge indices for each cell.</li>
<li><code class="docutils literal"><span class="pre">'cell_vert'</span></code> - cell-vertex connectivity: vertex indices for each cell.
Vertices of simple shaped cells are ordered according to vtk
file format. See figure in <a class="reference internal" href="#hybmeshpack.hmscript.export3d_grid_hmg" title="hybmeshpack.hmscript.export3d_grid_hmg"><code class="xref py py-func docutils literal"><span class="pre">export3d_grid_hmg()</span></code></a>.</li>
<li><code class="docutils literal"><span class="pre">'bnd'</span></code> - list of boundary faces indices,</li>
<li><code class="docutils literal"><span class="pre">'bt'</span></code> - boundary types for all faces including internal ones,</li>
<li><code class="docutils literal"><span class="pre">'bnd_bt'</span></code> - (boundary face, boundary feature) pairs</li>
</ul>
<p>Use <code class="docutils literal"><span class="pre">'face_dim'</span></code>, <code class="docutils literal"><span class="pre">'cell_fdim'</span></code>, <code class="docutils literal"><span class="pre">'cell_vdim'</span></code> to subdivide
plain <code class="docutils literal"><span class="pre">'face_vert'</span></code>, <code class="docutils literal"><span class="pre">'face_edge'</span></code>, <code class="docutils literal"><span class="pre">'cell_face'</span></code>, <code class="docutils literal"><span class="pre">'cell_vert'</span></code>
arrays by certain faces/cells.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.extrude_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">extrude_grid</code><span class="sig-paren">(</span><em>obj</em>, <em>zcoords</em>, <em>bottombc=0</em>, <em>topbc=0</em>, <em>sidebc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.extrude_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates 3D grid by extrusion of 2D grid along z-axis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>obj</strong> &#8211; 2d grid identifier</li>
<li><strong>zcoords</strong> (<em>list-of-floats</em>) &#8211; increasing vector of z values
which will be used to create 3d points</li>
<li><strong>bottombc</strong> &#8211; </li>
<li><strong>topbc</strong> &#8211; values which define boundary features of
3d grid at <code class="docutils literal"><span class="pre">z=min(zcoords)</span></code> and <code class="docutils literal"><span class="pre">z=max(zcoords)</span></code>
surfaces respectively.
Could be either a single boundary identifier for a whole
surface or a function: <code class="docutils literal"><span class="pre">(float</span> <span class="pre">x,</span> <span class="pre">float</span> <span class="pre">y,</span> <span class="pre">int</span> <span class="pre">cell_index)-&gt;bindex</span></code>
which takes central cell point x, y
coordinates and cell index as arguments and returns boundary type
(see example below).</li>
<li><strong>sidebc</strong> &#8211; <p>defines boundary features for side surfaces.</p>
<ul>
<li>If None than boundary types will be taken from corresponding
edges of 2D grid</li>
<li>If single boundary identifier then whole side surface will
have same boundary type</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3D grid identifier</p>
</td>
</tr>
</tbody>
</table>
<p>Use <a class="reference internal" href="#hybmeshpack.hmscript.partition_segment" title="hybmeshpack.hmscript.partition_segment"><code class="xref py py-func docutils literal"><span class="pre">partition_segment()</span></code></a> to define non-equidistant
<strong>zcoords</strong> with any desired refinement.</p>
<p>Example:</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># register boundary types</span>
<span class="k">global</span> <span class="n">bx0</span><span class="p">,</span> <span class="n">bx1</span><span class="p">,</span> <span class="n">by0</span><span class="p">,</span> <span class="n">by1</span><span class="p">,</span> <span class="n">bz0</span><span class="p">,</span> <span class="n">bz1</span><span class="p">,</span> <span class="n">bcustom</span>
<span class="n">bx0</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_boundary_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;x0-boundary&quot;</span><span class="p">)</span>
<span class="n">bx1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_boundary_type</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;x1-boundary&quot;</span><span class="p">)</span>
<span class="n">by0</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_boundary_type</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y0-boundary&quot;</span><span class="p">)</span>
<span class="n">by1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_boundary_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;y1-boundary&quot;</span><span class="p">)</span>
<span class="n">bz0</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_boundary_type</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;z0-boundary&quot;</span><span class="p">)</span>
<span class="n">bz1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_boundary_type</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;z1-boundary&quot;</span><span class="p">)</span>
<span class="n">bcustom</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_boundary_type</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s2">&quot;bcustom&quot;</span><span class="p">)</span>

<span class="c1"># unit square 2D grid</span>
<span class="n">square</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">add_unf_rect_grid</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>


<span class="c1"># assign boundary types to 2D geometry so it could be inherited by 3D object</span>
<span class="k">def</span> <span class="nf">assign_boundary2d</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bx0</span>
    <span class="k">if</span> <span class="n">x0</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bx1</span>
    <span class="k">if</span> <span class="n">y0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">by0</span>
    <span class="k">if</span> <span class="n">y0</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">by1</span>

<span class="n">hmscript</span><span class="o">.</span><span class="n">set_boundary_type</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">bfun</span><span class="o">=</span><span class="n">assign_boundary2d</span><span class="p">)</span>

<span class="c1"># calculate z coordinates with sine refinement towards z=0</span>
<span class="n">minz</span><span class="p">,</span> <span class="n">maxz</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">10</span>


<span class="c1"># refinement function [0, 1] -&gt; [0, 1]</span>
<span class="k">def</span> <span class="nf">reffun</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">zcoords</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">reffun</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">nz</span><span class="p">)</span>
    <span class="n">zcoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minz</span> <span class="o">+</span> <span class="p">(</span><span class="n">maxz</span> <span class="o">-</span> <span class="n">minz</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>

<span class="c1"># case 1: extrude without any boundary assignment</span>
<span class="n">res1</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">extrude_grid</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">zcoords</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="c1"># case 2: assign all boundary types:</span>
<span class="c1">#         x0, x1, y0, y1 are inherited from 2d geometry,</span>
<span class="c1">#         z0, z1 are defined explicitly</span>
<span class="n">res2</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">extrude_grid</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">zcoords</span><span class="p">,</span> <span class="n">bz0</span><span class="p">,</span> <span class="n">bz1</span><span class="p">)</span>


<span class="c1"># case 3: same as case 2 but select central face within z=0</span>
<span class="c1">#         surface and assign it with bcustom boundary type</span>
<span class="k">def</span> <span class="nf">assign_boundary3d_z0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bcustom</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bz0</span>

<span class="n">res3</span> <span class="o">=</span> <span class="n">hmscript</span><span class="o">.</span><span class="n">extrude_grid</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">zcoords</span><span class="p">,</span> <span class="n">assign_boundary3d_z0</span><span class="p">,</span> <span class="n">bz1</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.revolve_grid">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">revolve_grid</code><span class="sig-paren">(</span><em>obj</em>, <em>p1</em>, <em>p2</em>, <em>n_phi=None</em>, <em>phi=None</em>, <em>btype1=0</em>, <em>btype2=0</em>, <em>merge_central=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.revolve_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates 3D grid by revolution of 2D grid around a vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>obj</strong> &#8211; 2d grid identifier</li>
<li><strong>p1</strong> &#8211; </li>
<li><strong>p2</strong> &#8211; points in [x, y] format which define vector of rotation</li>
<li><strong>n_phi</strong> (<em>int</em>) &#8211; partition along circular coordinate.
If this parameter is defined then [0, 360] range will be divided
into equal parts and full revolution solid will be build.</li>
<li><strong>phi</strong> (<em>list-of-floats</em>) &#8211; increasing vector defining
custom partition of angular range.
This parameter will be processed if <strong>n_phi</strong> is None.
If the last value of <strong>phi</strong> is not equal to first one
plus 360 degree than
incomplete revolution solid will be built.</li>
<li><strong>btype1</strong> &#8211; </li>
<li><strong>btype2</strong> &#8211; boundary identifiers for surfaces which will be build
as a result of incomplete rotation at end values of <strong>phi</strong> vector.</li>
<li><strong>merge_central</strong> (<em>bool</em>) &#8211; if rotation vector coincides
with boundary edges of input grid then this parameter
defines whether central cells derived from the revolution
of respective boundary cells should be merged into one
complex finite volume (True) or left as they are (False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3D grid identifier</p>
</td>
</tr>
</tbody>
</table>
<p>All points of input grid should lie to the one side of rotation
vector.</p>
<p>Use <a class="reference internal" href="#hybmeshpack.hmscript.partition_segment" title="hybmeshpack.hmscript.partition_segment"><code class="xref py py-func docutils literal"><span class="pre">partition_segment()</span></code></a> to define non-equidistant
<strong>phi</strong> with any desired refinement if needed.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.tetrahedral_fill">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">tetrahedral_fill</code><span class="sig-paren">(</span><em>domain</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.tetrahedral_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills 3D domain with tetrahedral mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>domain</strong> &#8211; surface/3d grid identifier (or list of identifiers)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">3d grid identifier</td>
</tr>
</tbody>
</table>
<p>Domain is defined by any number of closed surfaces passed in <strong>domain</strong>
argument. Internal nesting procedure
will be executed to built target domain out of given surfaces.
Boundary surface could possibly contain faces built
by any number of vertices.
However if boundary face is not a triangle than a n-side pyramid
will be built at its site. Hence resulting grid will not be strictly
tetrahedral.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By now program uses simplified bounding box based nesting
algorithm. It could give improper results for complicated
surface structures. Be sure that passed surface list nesting equals
nesting of respective surface bounding boxes.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.merge_grids3">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">merge_grids3</code><span class="sig-paren">(</span><em>g1</em>, <em>g2</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.merge_grids3" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges 3d grids into single one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g1</strong> &#8211; </li>
<li><strong>g2</strong> &#8211; 3d source grids identifiers.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">new grid identifier.</p>
</td>
</tr>
</tbody>
</table>
<p>Merge procedure will process only strictly
coincident boundary primitives.</p>
</dd></dl>

</div>
<div class="section" id="id6">
<h2>Export<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="hybmeshpack.hmscript.export_grid_hmg">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export_grid_hmg</code><span class="sig-paren">(</span><em>gid</em>, <em>fname</em>, <em>fmt='ascii'</em>, <em>afields=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export_grid_hmg" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports 2d grid to hybmesh native format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; single or list of grid identifiers</li>
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename</li>
<li><strong>fmt</strong> (<em>str</em>) &#8211; <p>output data format:</p>
<ul>
<li><code class="docutils literal"><span class="pre">'ascii'</span></code> - all fields will be saved as text fields,</li>
<li><code class="docutils literal"><span class="pre">'bin'</span></code> - all fields will be saved in binary section,</li>
<li><code class="docutils literal"><span class="pre">'fbin'</span></code> - only floating point fields will be saved
in binary section.</li>
</ul>
</li>
<li><strong>afields</strong> (<em>list-of-str</em>) &#8211; additional data which should be placed
to output file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p>To save additional data into grid file
<a class="reference internal" href="fileformats.html#udef-fields"><span class="std std-ref">user defined fields</span></a>
place any of these strings into <strong>afields</strong> list:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'cell-vertices'</span></code> &#8211; cell vertex connectivity. All vertices will
be written in counterclockwise direction;</li>
<li><code class="docutils literal"><span class="pre">'cell-edges'</span></code> &#8211; cell edge connectivity. All edges will be written
in counterclockwise direction.</li>
</ul>
<p>See <a class="reference internal" href="fileformats.html#grid2d-file"><span class="std std-ref">2D Grid Format</span></a> for format description.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export_grid_vtk">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export_grid_vtk</code><span class="sig-paren">(</span><em>gid</em>, <em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export_grid_vtk" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports 2d grid to vtk format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; single or list of 2d grid identifiers</li>
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export_grid_msh">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export_grid_msh</code><span class="sig-paren">(</span><em>gid</em>, <em>fname</em>, <em>periodic_pairs=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export_grid_msh" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports grid to fluent msh format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; 2d grid file identifier or list of identifiers.</li>
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename</li>
<li><strong>periodic_pairs</strong> (<em>list</em>) &#8211; <p><code class="docutils literal"><span class="pre">[b-periodic0,</span> <span class="pre">b-shadow0,</span> <span class="pre">is_reversed0,</span> <span class="pre">b-periodic1,</span>
<span class="pre">b-shadow1,</span> <span class="pre">is_reversed1,</span> <span class="pre">...]</span></code> list defining periodic boundaries.</p>
<p>Each periodic condition is defined by three values:</p>
<ul>
<li><code class="docutils literal"><span class="pre">b-periodic</span></code> - boundary identifier for periodic contour segment</li>
<li><code class="docutils literal"><span class="pre">b-shadow</span></code> - boundary identifier for shadow contour segment</li>
<li><code class="docutils literal"><span class="pre">is_reversed</span></code> - boolean which defines whether shadow contour segment
should be reversed so that first point of periodic segment be
equivalent to last point of shadow segment</li>
</ul>
<p>Periodic and shadow boundary segments should be singly connected and
topologically equivalent.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p>Only grids with triangle/quadrangle cells could be exported.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export_grid_gmsh">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export_grid_gmsh</code><span class="sig-paren">(</span><em>gid</em>, <em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export_grid_gmsh" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports grid to gmsh ascii format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; single or list of grid identifiers</li>
<li><strong>fname</strong> &#8211; output filename</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p>Only grids with triangle/quadrangle cells could be exported.</p>
<p>Boundary edges will be exported as Elements of &#8220;Line&#8221; type.
All boundary types which present in grid will be exported as
Physical Groups with an id
identical to boundary index and a respective Physical Name.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export_grid_tecplot">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export_grid_tecplot</code><span class="sig-paren">(</span><em>gid</em>, <em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export_grid_tecplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports grid to tecplot ascii format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gid</strong> &#8211; grid identifier or list of identifiers</li>
<li><strong>fname</strong> &#8211; output filename</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p>All cells will be saved as FEPolygon elements.
Boundary segments with same boundary type will be converted
to separate zones.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export_contour_hmc">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export_contour_hmc</code><span class="sig-paren">(</span><em>cid</em>, <em>fname</em>, <em>fmt='ascii'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export_contour_hmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports contours to native format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cid</strong> &#8211; contour identifier or list of identifiers,</li>
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename</li>
<li><strong>fmt</strong> (<em>str</em>) &#8211; <p>output data format:</p>
<ul>
<li><code class="docutils literal"><span class="pre">'ascii'</span></code> - all fields will be saved as text fields,</li>
<li><code class="docutils literal"><span class="pre">'bin'</span></code> - all fields will be saved in binary section,</li>
<li><code class="docutils literal"><span class="pre">'fbin'</span></code> - only floating point fields will be saved
in binary section.</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p>See <a class="reference internal" href="fileformats.html#contour2d-file"><span class="std std-ref">2D Contour Format</span></a> for format description.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export_contour_vtk">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export_contour_vtk</code><span class="sig-paren">(</span><em>cid</em>, <em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export_contour_vtk" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports contour to vtk format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cid</strong> &#8211; contour identifier or list of identifiers,</li>
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export_contour_tecplot">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export_contour_tecplot</code><span class="sig-paren">(</span><em>cid</em>, <em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export_contour_tecplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports contour to tecplot ascii format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cid</strong> &#8211; contour identifier or list of identifiers,</li>
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<p>All contour segments will be saved to a zone called &#8220;Contour&#8221;.
Additional zones will be created for all segments with same
boundary type.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export3d_grid_hmg">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export3d_grid_hmg</code><span class="sig-paren">(</span><em>gid</em>, <em>fname</em>, <em>fmt='ascii'</em>, <em>afields=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export3d_grid_hmg" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports 3d grid to hybmesh native format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>gid</strong> &#8211; single or list of grid identifiers</li>
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename</li>
<li><strong>fmt</strong> (<em>str</em>) &#8211; <p>output data format:</p>
<ul>
<li><code class="docutils literal"><span class="pre">'ascii'</span></code> - all fields will be saved as text fields,</li>
<li><code class="docutils literal"><span class="pre">'bin'</span></code> - all fields will be saved in binary section,</li>
<li><code class="docutils literal"><span class="pre">'fbin'</span></code> - only floating point fields will be saved
in binary section.</li>
</ul>
</li>
<li><strong>afields</strong> (<em>list-of-str</em>) &#8211; additional data which should be placed
to output file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>To save additional data into grid file
<a class="reference internal" href="fileformats.html#udef-fields"><span class="std std-ref">user defined fields</span></a>
place any of these strings into <strong>afields</strong> list:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">'face-vertices'</span></code> - face vertex ordered connectivity,</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'cell-faces'</span></code> - cell face connectivity,</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'cell-vertices'</span></code> - cell vertex connectivity,</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'linfem'</span></code> - tries to write cells-vertex connectivity
for cell types most widely used in linear fem solvers.
Supported cell types are: tetrahedron (4 nodes), hexahedron (8),
prism(6), pyramid(5).
Record for each of those cells contains points in order prescribed
by vtk file format. If a cell is not of one of those types
then a zero length connectivity list will be written for it.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/vtk_cells3d.png"><img alt="_images/vtk_cells3d.png" src="_images/vtk_cells3d.png" style="width: 500px;" /></a>
</div>
</li>
</ul>
<p>See <a class="reference internal" href="fileformats.html#grid3d-file"><span class="std std-ref">3D Grid format</span></a> for format description.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export3d_grid_vtk">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export3d_grid_vtk</code><span class="sig-paren">(</span><em>gid</em>, <em>fname_grid=None</em>, <em>fname_surface=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export3d_grid_vtk" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports 3D grid and its surface to vtk ascii format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>gid</strong> &#8211; 3D grid file identifier or list of identifiers</li>
<li><strong>fname_grid</strong> (<em>str-or-None</em>) &#8211; filename for grid output.</li>
<li><strong>fname_surface</strong> (<em>str-or-None</em>) &#8211; filename for surface output.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Only hexahedron, prism, wedge and tetrahedron cells could be exported
as a grid. Surface export takes arbitrary grid.</p>
<p>If a filename is <em>None</em> then respective export will be omitted.</p>
<p>Boundary types are exported as a field called <code class="docutils literal"><span class="pre">boundary_types</span></code> to
surface output file.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export3d_grid_gmsh">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export3d_grid_gmsh</code><span class="sig-paren">(</span><em>gid</em>, <em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export3d_grid_gmsh" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports 3D grid to gmsh ascii format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>gid</strong> &#8211; grid identifier or list of identifiers</li>
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Only grids with tetrahedral/hexahedral/prism/pyramid cells
could be exported.</p>
<p>Boundary edges will be exported as Elements of triangle/quadrangle type.
All boundary types which present in grid will be exported as
Physical Groups with an id identical to boundary index and
respective Physical Name.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export3d_grid_msh">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export3d_grid_msh</code><span class="sig-paren">(</span><em>gid</em>, <em>fname</em>, <em>periodic_pairs=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export3d_grid_msh" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports 3D grid to fluent msh ascii format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>gid</strong> &#8211; 3D grid file identifier or list of identifiers</li>
<li><strong>grid</strong> (<em>str</em>) &#8211; filename for output</li>
<li><strong>periodic_pairs</strong> (<em>list</em>) &#8211; <p><code class="docutils literal"><span class="pre">[periodic-0,</span> <span class="pre">shadow-0,</span> <span class="pre">periodic-point-0,</span> <span class="pre">shadow-point-0,</span>
<span class="pre">periodic-1,</span> <span class="pre">shadow-1,</span> <span class="pre">periodic-point-1,</span> <span class="pre">...]</span></code></p>
<p>Each periodic pair is defined by four values:</p>
<ul>
<li><code class="docutils literal"><span class="pre">periodic</span></code> - boundary identifier for periodic surface</li>
<li><code class="docutils literal"><span class="pre">shadow</span></code> - boundary identifier for shadow surface</li>
<li><code class="docutils literal"><span class="pre">periodic-point</span></code> - point in [x, y, z] format on periodic contour</li>
<li><code class="docutils literal"><span class="pre">shadow-point</span></code> - point in [x, y, z] format on shadow contour</li>
</ul>
<p>Given points will be projected to closest vertex on the boundaries
of respective subsurfaces.</p>
<p>Periodic and shadow subsurfaces should be singly connected and
topologically equivalent with respect to given points.
For surface 2D topology definition periodic/shadow surfaces are taken
with outside/inside normals respectively.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export3d_grid_tecplot">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export3d_grid_tecplot</code><span class="sig-paren">(</span><em>gid</em>, <em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export3d_grid_tecplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports 3D grid to tecplot ascii format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>gid</strong> &#8211; 3D grid file identifier or list of identifiers</li>
<li><strong>grid</strong> (<em>str</em>) &#8211; filename for output</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>A grid zone and zones for each boundary surface defined by boundary type
will be created in the output file.</p>
<p>All 3D cells will be saved as FEPOLYHEDRON elements.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export3d_surface_hmc">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export3d_surface_hmc</code><span class="sig-paren">(</span><em>sid</em>, <em>fname</em>, <em>fmt='ascii'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export3d_surface_hmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports 3d surface to hybmesh native format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sid</strong> &#8211; single or list of surface identifiers</li>
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename</li>
<li><strong>fmt</strong> (<em>str</em>) &#8211; <p>output data format:</p>
<ul>
<li><code class="docutils literal"><span class="pre">'ascii'</span></code> - all fields will be saved as text fields,</li>
<li><code class="docutils literal"><span class="pre">'bin'</span></code> - all fields will be saved in binary section,</li>
<li><code class="docutils literal"><span class="pre">'fbin'</span></code> - only floating point fields will be saved
in binary section.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>See <a class="reference internal" href="fileformats.html#surface3d-file"><span class="std std-ref">3D Surface format</span></a> for format description.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.export_all_hmd">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">export_all_hmd</code><span class="sig-paren">(</span><em>fname</em>, <em>fmt='ascii'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.export_all_hmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports all geometrical data to native format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) &#8211; output filename</li>
<li><strong>fmt</strong> (<em>str</em>) &#8211; <p>output data format:</p>
<ul>
<li><code class="docutils literal"><span class="pre">'ascii'</span></code> - all fields will be saved as text fields,</li>
<li><code class="docutils literal"><span class="pre">'bin'</span></code> - all fields will be saved in binary section,</li>
<li><code class="docutils literal"><span class="pre">'fbin'</span></code> - only floating point fields will be saved
in binary section.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>See <a class="reference internal" href="fileformats.html#nativeformat"><span class="std std-ref">Native File Formats</span></a> for description.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.save_project">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">save_project</code><span class="sig-paren">(</span><em>fname</em>, <em>fmt='ascii'</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.save_project" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves current command flow and data to HybMesh project file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) &#8211; file name</li>
<li><strong>fmt</strong> (<em>str</em>) &#8211; <p>output data format:</p>
<ul>
<li><code class="docutils literal"><span class="pre">'ascii'</span></code> - all fields will be saved as text fields,</li>
<li><code class="docutils literal"><span class="pre">'bin'</span></code> - all fields will be saved in binary section,</li>
<li><code class="docutils literal"><span class="pre">'fbin'</span></code> - only floating point fields will be saved
in binary section.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>See <a class="reference internal" href="fileformats.html#hmp-file"><span class="std std-ref">Project Workflow Format</span></a> for description.</p>
</dd></dl>

</div>
<div class="section" id="id7">
<h2>Import<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="hybmeshpack.hmscript.import_grid_hmg">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">import_grid_hmg</code><span class="sig-paren">(</span><em>fname</em>, <em>gridname=''</em>, <em>allgrids=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.import_grid_hmg" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports grid from native hmg file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fname</strong> (<em>str</em>) &#8211; file name.</li>
<li><strong>gridname</strong> (<em>str</em>) &#8211; name of a grid to find in the file.
If <strong>gridname</strong> is not specified then the first grid will be taken.</li>
<li><strong>allgrids</strong> (<em>bool</em>) &#8211; if True then all grids from the file
will be imported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid identifier or list of identifiers if <strong>allgrids</strong> is set.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.import_grid_msh">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">import_grid_msh</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.import_grid_msh" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports grid from fluent msh file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> (<em>str</em>) &#8211; file name</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">grid identifier</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.import_grid_gmsh">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">import_grid_gmsh</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.import_grid_gmsh" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports grid from gmsh ascii file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> (<em>str</em>) &#8211; file name</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">grid identifier</td>
</tr>
</tbody>
</table>
<p>Only triangle and quad elements are supported.</p>
<p>Boundary types could be exported by passing boundary edges as
certain Elements of &#8220;Line&#8221; type. Their physical entity tag
(first one amoung real tags) will be treated as their boundary index.
For each such index the new boundary type will be registered in the program
flow if it has not been registered yet. Name for the new boundary
type will be taken from PhysicalNames field if it exists, otherwise
the default name &#8220;gmsh-boundary-index&#8221; will be used.</p>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.import_contour_hmc">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">import_contour_hmc</code><span class="sig-paren">(</span><em>fname</em>, <em>contname=''</em>, <em>allconts=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.import_contour_hmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports contour from hybmesh native format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fname</strong> (<em>str</em>) &#8211; filename</li>
<li><strong>contname</strong> (<em>str</em>) &#8211; name of the contour to import. If <strong>contname</strong>
is not specified then the first one will be taken.</li>
<li><strong>allconts</strong> (<em>bool</em>) &#8211; if True then all contours from the file
will be imported. <strong>contname</strong> will be ignored.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">contour identifier/list of identifiers if <strong>allconts</strong> is set.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.import3d_grid_hmg">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">import3d_grid_hmg</code><span class="sig-paren">(</span><em>fname</em>, <em>gridname=''</em>, <em>allgrids=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.import3d_grid_hmg" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports grid from native hmg file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fname</strong> (<em>str</em>) &#8211; file name.</li>
<li><strong>gridname</strong> (<em>str</em>) &#8211; name of the grid to import. If not specified
then the first grid will be loaded.</li>
<li><strong>allgrids</strong> (<em>bool</em>) &#8211; if True then all grids from the file
will be imported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid identifier/list of identifiers if <strong>allgrids</strong> is set.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.import3d_surface_hmc">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">import3d_surface_hmc</code><span class="sig-paren">(</span><em>fname</em>, <em>srfname=''</em>, <em>allsurfs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.import3d_surface_hmc" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports surface from hybmesh native format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fname</strong> (<em>str</em>) &#8211; filename</li>
<li><strong>srfname</strong> (<em>str</em>) &#8211; name of the surface to import. If <strong>srfname</strong>
is not specified then the first one will be taken.</li>
<li><strong>allsurfs</strong> (<em>bool</em>) &#8211; if True then all surfaces from the file
will be imported. <strong>srfname</strong> will be ignored.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">surface identifier or
list of identifiers if <strong>allsurfs</strong> is set.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.import_all_hmd">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">import_all_hmd</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.import_all_hmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Imports all geometry objects found in a file of native format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> (<em>str</em>) &#8211; filename</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list of loaded objects as
<code class="docutils literal"><span class="pre">[[grid2d</span> <span class="pre">ids],</span> <span class="pre">[contour2d</span> <span class="pre">ids],</span> <span class="pre">[grid3d</span> <span class="pre">ids],</span> <span class="pre">[surface3d</span> <span class="pre">ids]]</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hybmeshpack.hmscript.load_project">
<code class="descclassname">hybmeshpack.hmscript.</code><code class="descname">load_project</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="headerlink" href="#hybmeshpack.hmscript.load_project" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads command flow and data from HybMesh project file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> (<em>str</em>) &#8211; file name</td>
</tr>
</tbody>
</table>
<p>All existing data will be lost.</p>
<p>See <a class="reference internal" href="fileformats.html#hmp-file"><span class="std std-ref">Project Workflow Format</span></a> for description.</p>
</dd></dl>

</div>
<div class="section" id="introductory-examples">
<h2>Introductory Examples<a class="headerlink" href="#introductory-examples" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="intro_example1.html#example1"><span class="std std-ref">Example 1</span></a> uses <a class="reference internal" href="#hybmeshpack.hmscript.exclude_contours" title="hybmeshpack.hmscript.exclude_contours"><code class="xref py py-func docutils literal"><span class="pre">exclude_contours()</span></code></a>,
<a class="reference internal" href="#hybmeshpack.hmscript.unite_grids" title="hybmeshpack.hmscript.unite_grids"><code class="xref py py-func docutils literal"><span class="pre">unite_grids()</span></code></a>,
<a class="reference internal" href="#hybmeshpack.hmscript.build_boundary_grid1" title="hybmeshpack.hmscript.build_boundary_grid1"><code class="xref py py-func docutils literal"><span class="pre">build_boundary_grid1()</span></code></a>.</li>
<li><a class="reference internal" href="intro_example2.html#example2"><span class="std std-ref">Example 2</span></a> uses <a class="reference internal" href="#hybmeshpack.hmscript.unite_grids" title="hybmeshpack.hmscript.unite_grids"><code class="xref py py-func docutils literal"><span class="pre">unite_grids()</span></code></a>. Illustrates boundary
features translation.</li>
<li><a class="reference internal" href="intro_example3.html#example3"><span class="std std-ref">Example 3</span></a> uses <a class="reference internal" href="#hybmeshpack.hmscript.build_boundary_grid" title="hybmeshpack.hmscript.build_boundary_grid"><code class="xref py py-func docutils literal"><span class="pre">build_boundary_grid()</span></code></a>. Complicated
boundary grid building.</li>
<li><a class="reference internal" href="intro_example4.html#example4"><span class="std std-ref">Example 4</span></a> uses <a class="reference internal" href="#hybmeshpack.hmscript.map_grid" title="hybmeshpack.hmscript.map_grid"><code class="xref py py-func docutils literal"><span class="pre">map_grid()</span></code></a>, <a class="reference internal" href="#hybmeshpack.hmscript.snap_grid_to_contour" title="hybmeshpack.hmscript.snap_grid_to_contour"><code class="xref py py-func docutils literal"><span class="pre">snap_grid_to_contour()</span></code></a>.</li>
<li><a class="reference internal" href="intro_example5.html#example5"><span class="std std-ref">Example 5</span></a> uses <a class="reference internal" href="#hybmeshpack.hmscript.extrude_grid" title="hybmeshpack.hmscript.extrude_grid"><code class="xref py py-func docutils literal"><span class="pre">extrude_grid()</span></code></a>, <a class="reference internal" href="#hybmeshpack.hmscript.export3d_grid_msh" title="hybmeshpack.hmscript.export3d_grid_msh"><code class="xref py py-func docutils literal"><span class="pre">export3d_grid_msh()</span></code></a> with
3D periodic conditions.</li>
<li><a class="reference internal" href="intro_example6.html#example6"><span class="std std-ref">Example 6</span></a> uses <a class="reference internal" href="#hybmeshpack.hmscript.partition_contour" title="hybmeshpack.hmscript.partition_contour"><code class="xref py py-func docutils literal"><span class="pre">partition_contour()</span></code></a>, <a class="reference internal" href="#hybmeshpack.hmscript.matched_partition" title="hybmeshpack.hmscript.matched_partition"><code class="xref py py-func docutils literal"><span class="pre">matched_partition()</span></code></a>,
<a class="reference internal" href="#hybmeshpack.hmscript.stripe" title="hybmeshpack.hmscript.stripe"><code class="xref py py-func docutils literal"><span class="pre">stripe()</span></code></a>, <a class="reference internal" href="#hybmeshpack.hmscript.triangulate_domain" title="hybmeshpack.hmscript.triangulate_domain"><code class="xref py py-func docutils literal"><span class="pre">triangulate_domain()</span></code></a>, <a class="reference internal" href="#hybmeshpack.hmscript.pebi_fill" title="hybmeshpack.hmscript.pebi_fill"><code class="xref py py-func docutils literal"><span class="pre">pebi_fill()</span></code></a>.
Different approaches to non-regular domain meshing.</li>
</ul>
<div class="toctree-wrapper compound">
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Python Script Interface</a><ul>
<li><a class="reference internal" href="#script-invocation">Script Invocation</a></li>
<li><a class="reference internal" href="#design">Design</a></li>
<li><a class="reference internal" href="#exception-handling">Exception Handling</a></li>
<li><a class="reference internal" href="#list-of-functions">List of Functions</a><ul>
<li><a class="reference internal" href="#general-routines">General routines</a></li>
<li><a class="reference internal" href="#contour-operations">Contour operations</a></li>
<li><a class="reference internal" href="#d-grid-operations">2D grid operations</a></li>
<li><a class="reference internal" href="#surface-operations">Surface operations</a></li>
<li><a class="reference internal" href="#id1">3D grid operations</a></li>
<li><a class="reference internal" href="#export">Export</a></li>
<li><a class="reference internal" href="#import">Import</a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-procedures">General Procedures</a></li>
<li><a class="reference internal" href="#id2">Contour Operations</a></li>
<li><a class="reference internal" href="#id3">2D Grid Operations</a></li>
<li><a class="reference internal" href="#id4">Surface Operations</a></li>
<li><a class="reference internal" href="#id5">3D Grid Operations</a></li>
<li><a class="reference internal" href="#id6">Export</a></li>
<li><a class="reference internal" href="#id7">Import</a></li>
<li><a class="reference internal" href="#introductory-examples">Introductory Examples</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="prototypes.html"
                        title="previous chapter">Grid Prototypes</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="intro_example1.html"
                        title="next chapter">Example 1</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pyinterface.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro_example1.html" title="Example 1"
             >next</a> |</li>
        <li class="right" >
          <a href="prototypes.html" title="Grid Prototypes"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">HybMesh 0.5.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, KalininEI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>